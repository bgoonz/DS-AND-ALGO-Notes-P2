
class TreeNode {

  constructor (val) {
    this.val = val;
    this.left = null;
    this.right = null;
  }
}

module.exports = {
    TreeNode
}; 
  TreeNode
}
 13  lib/tree_order.js 

function inOrderArray(root) {
  // if the root is null, return an empty array

  if(root === null) return [];
  // get the array for visiting the left node
  // get the array for visiting the right node

  const leftBranch = inOrderArray(root.left);
  const rightBranch = inOrderArray(root.right);
  // return the left array concatenated with the root value
  //   concatenated with the right array
  return leftBranch.concat(root.val).concat(rightBranch);
}

function postOrderArray(root) {
  // if the root is null, return an empty array

  if (root === null) return [];
  // get the array for visiting the left node
  // get the array for visiting the right node

  const leftBranch = postOrderArray(root.left);
  const rightBranch = postOrderArray(root.right);
  // return the left array concatenated with the right array
  //   concatenated with the root value
  return leftBranch.concat(rightBranch).concat(root.val);

}


 112  test/test.js 

const { expect } = require('chai');
const { TreeNode } = require('../lib/tree_node.js');
const { inOrderArray, postOrderArray } = require('../lib/tree_order.js');
const { buildTree } = require('../lib/leet_code_105.js');

const { expect } = require('chai')
const { TreeNode } = require('../lib/tree_node.js')
const { inOrderArray, postOrderArray } = require('../lib/tree_order.js')
const { buildTree } = require('../lib/leet_code_105.js')

describe('TreeNode', () => {
    describe('#constructor()', () => {
        it('should set the `val` property to the given arg', () => {
            let a = new TreeNode('a');
            expect(a.val).to.equal('a');
  describe('#constructor()', () => {
    it('should set the `val` property to the given arg', () => {
      const a = new TreeNode('a')
      expect(a.val).to.equal('a')

            let b = new TreeNode('b');
            expect(b.val).to.equal('b');
        });
      const b = new TreeNode('b')
      expect(b.val).to.equal('b')
    })

        it('should initialize `left` and `right` properties to null', () => {
            let a = new TreeNode('a');
            expect(a.left).to.equal(null);
            expect(a.right).to.equal(null);            
        });
    });
});
    it('should initialize `left` and `right` properties to null', () => {
      const a = new TreeNode('a')
      expect(a.left).to.equal(null)
      expect(a.right).to.equal(null)
    })
  })
})

describe('TreeOrder', () => {
    let root;

    beforeEach(() => {
        root = new TreeNode('a');
        let b = new TreeNode('b');
        let c = new TreeNode('c');
        let d = new TreeNode('d');
        let e = new TreeNode('e');
        let f = new TreeNode('f');
  let root

        root.left = b;
        root.right = c;
        b.left = d;
        b.right = e;
        c.right = f;
    });
  beforeEach(() => {
    root = new TreeNode('a')
    const b = new TreeNode('b')
    const c = new TreeNode('c')
    const d = new TreeNode('d')
    const e = new TreeNode('e')
    const f = new TreeNode('f')

    root.left = b
    root.right = c
    b.left = d
    b.right = e
    c.right = f
  })

    describe('inOrderArray()', () => {
        context('when given an empty tree', () => {
            it('should return an empty array', () => {
                expect(inOrderArray(null)).to.eql([]);
            });
        });
  describe('inOrderArray()', () => {
    context('when given an empty tree', () => {
      it('should return an empty array', () => {
        expect(inOrderArray(null)).to.eql([])
      })
    })

        it('should return an array containing values of the binary tree following In-Order', () => {
            expect(inOrderArray(root)).to.eql(['d', 'b', 'e', 'a', 'c', 'f']);
        });
    });
    it('should return an array containing values of the binary tree following In-Order', () => {
      expect(inOrderArray(root)).to.eql(['d', 'b', 'e', 'a', 'c', 'f'])
    })
  })

    describe('postOrderArray()', () => {
        context('when given an empty tree', () => {
            it('should return an empty array', () => {
                expect(postOrderArray(null)).to.eql([]);
            });
        });
  describe('postOrderArray()', () => {
    context('when given an empty tree', () => {
      it('should return an empty array', () => {
        expect(postOrderArray(null)).to.eql([])
      })
    })

        it('should return an array containing values of the binary tree following Post-Order', () => {
            expect(postOrderArray(root)).to.eql(['d', 'e', 'b', 'f', 'c', 'a']);
        });
    });
});
    it('should return an array containing values of the binary tree following Post-Order', () => {
      expect(postOrderArray(root)).to.eql(['d', 'e', 'b', 'f', 'c', 'a'])
    })
  })
})

describe('BONUS: Leet Code #105', () => {
    it('https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/');
});
  it('https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/')
})
0 comments on commit 9bd11b5
@bgoonz
  
 
