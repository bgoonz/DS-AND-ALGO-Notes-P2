<!DOCTYPE html>
<html>

<head>
    <title>wed-my.md</title>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">

    <style>
        /* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
        /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

        body {
            font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
            font-size: var(--vscode-markdown-font-size, 14px);
            padding: 0 26px;
            line-height: var(--vscode-markdown-line-height, 22px);
            word-wrap: break-word;
        }

        #code-csp-warning {
            position: fixed;
            top: 0;
            right: 0;
            color: white;
            margin: 16px;
            text-align: center;
            font-size: 12px;
            font-family: sans-serif;
            background-color: #444444;
            cursor: pointer;
            padding: 6px;
            box-shadow: 1px 1px 1px rgba(0, 0, 0, .25);
        }

        #code-csp-warning:hover {
            text-decoration: none;
            background-color: #007acc;
            box-shadow: 2px 2px 2px rgba(0, 0, 0, .25);
        }

        body.scrollBeyondLastLine {
            margin-bottom: calc(100vh - 22px);
        }

        body.showEditorSelection .code-line {
            position: relative;
        }

        body.showEditorSelection .code-active-line:before,
        body.showEditorSelection .code-line:hover:before {
            content: "";
            display: block;
            position: absolute;
            top: 0;
            left: -12px;
            height: 100%;
        }

        body.showEditorSelection li.code-active-line:before,
        body.showEditorSelection li.code-line:hover:before {
            left: -30px;
        }

        .vscode-light.showEditorSelection .code-active-line:before {
            border-left: 3px solid rgba(0, 0, 0, 0.15);
        }

        .vscode-light.showEditorSelection .code-line:hover:before {
            border-left: 3px solid rgba(0, 0, 0, 0.40);
        }

        .vscode-light.showEditorSelection .code-line .code-line:hover:before {
            border-left: none;
        }

        .vscode-dark.showEditorSelection .code-active-line:before {
            border-left: 3px solid rgba(255, 255, 255, 0.4);
        }

        .vscode-dark.showEditorSelection .code-line:hover:before {
            border-left: 3px solid rgba(255, 255, 255, 0.60);
        }

        .vscode-dark.showEditorSelection .code-line .code-line:hover:before {
            border-left: none;
        }

        .vscode-high-contrast.showEditorSelection .code-active-line:before {
            border-left: 3px solid rgba(255, 160, 0, 0.7);
        }

        .vscode-high-contrast.showEditorSelection .code-line:hover:before {
            border-left: 3px solid rgba(255, 160, 0, 1);
        }

        .vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
            border-left: none;
        }

        img {
            max-width: 100%;
            max-height: 100%;
        }

        a {
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        a:focus,
        input:focus,
        select:focus,
        textarea:focus {
            outline: 1px solid -webkit-focus-ring-color;
            outline-offset: -1px;
        }

        hr {
            border: 0;
            height: 2px;
            border-bottom: 2px solid;
        }

        h1 {
            padding-bottom: 0.3em;
            line-height: 1.2;
            border-bottom-width: 1px;
            border-bottom-style: solid;
        }

        h1,
        h2,
        h3 {
            font-weight: normal;
        }

        table {
            border-collapse: collapse;
        }

        table>thead>tr>th {
            text-align: left;
            border-bottom: 1px solid;
        }

        table>thead>tr>th,
        table>thead>tr>td,
        table>tbody>tr>th,
        table>tbody>tr>td {
            padding: 5px 10px;
        }

        table>tbody>tr+tr>td {
            border-top: 1px solid;
        }

        blockquote {
            margin: 0 7px 0 5px;
            padding: 0 16px 0 10px;
            border-left-width: 5px;
            border-left-style: solid;
        }

        code {
            font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
            font-size: 1em;
            line-height: 1.357em;
        }

        body.wordWrap pre {
            white-space: pre-wrap;
        }

        pre:not(.hljs),
        pre.hljs code>div {
            padding: 16px;
            border-radius: 3px;
            overflow: auto;
        }

        pre code {
            color: var(--vscode-editor-foreground);
            tab-size: 4;
        }

        /** Theming */

        .vscode-light pre {
            background-color: rgba(220, 220, 220, 0.4);
        }

        .vscode-dark pre {
            background-color: rgba(10, 10, 10, 0.4);
        }

        .vscode-high-contrast pre {
            background-color: rgb(0, 0, 0);
        }

        .vscode-high-contrast h1 {
            border-color: rgb(0, 0, 0);
        }

        .vscode-light table>thead>tr>th {
            border-color: rgba(0, 0, 0, 0.69);
        }

        .vscode-dark table>thead>tr>th {
            border-color: rgba(255, 255, 255, 0.69);
        }

        .vscode-light h1,
        .vscode-light hr,
        .vscode-light table>tbody>tr+tr>td {
            border-color: rgba(0, 0, 0, 0.18);
        }

        .vscode-dark h1,
        .vscode-dark hr,
        .vscode-dark table>tbody>tr+tr>td {
            border-color: rgba(255, 255, 255, 0.18);
        }
    </style>

    <style>
        /* Tomorrow Theme */
        /* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
        /* Original theme - https://github.com/chriskempson/tomorrow-theme */

        /* Tomorrow Comment */
        .hljs-comment,
        .hljs-quote {
            color: #8e908c;
        }

        /* Tomorrow Red */
        .hljs-variable,
        .hljs-template-variable,
        .hljs-tag,
        .hljs-name,
        .hljs-selector-id,
        .hljs-selector-class,
        .hljs-regexp,
        .hljs-deletion {
            color: #c82829;
        }

        /* Tomorrow Orange */
        .hljs-number,
        .hljs-built_in,
        .hljs-builtin-name,
        .hljs-literal,
        .hljs-type,
        .hljs-params,
        .hljs-meta,
        .hljs-link {
            color: #f5871f;
        }

        /* Tomorrow Yellow */
        .hljs-attribute {
            color: #eab700;
        }

        /* Tomorrow Green */
        .hljs-string,
        .hljs-symbol,
        .hljs-bullet,
        .hljs-addition {
            color: #718c00;
        }

        /* Tomorrow Blue */
        .hljs-title,
        .hljs-section {
            color: #4271ae;
        }

        /* Tomorrow Purple */
        .hljs-keyword,
        .hljs-selector-tag {
            color: #8959a8;
        }

        .hljs {
            display: block;
            overflow-x: auto;
            color: #4d4d4c;
            padding: 0.5em;
        }

        .hljs-emphasis {
            font-style: italic;
        }

        .hljs-strong {
            font-weight: bold;
        }
    </style>

    <style>
        /*
 * Markdown PDF CSS
 */

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
            padding: 0 12px;
        }

        pre {
            background-color: #f8f8f8;
            border: 1px solid #cccccc;
            border-radius: 3px;
            overflow-x: auto;
            white-space: pre-wrap;
            overflow-wrap: break-word;
        }

        pre:not(.hljs) {
            padding: 23px;
            line-height: 19px;
        }

        blockquote {
            background: rgba(127, 127, 127, 0.1);
            border-color: rgba(0, 122, 204, 0.5);
        }

        .emoji {
            height: 1.4em;
        }

        code {
            font-size: 14px;
            line-height: 19px;
        }

        /* for inline code */
        :not(pre):not(.hljs)>code {
            color: #C9AE75;
            /* Change the old color so it seems less like an error */
            font-size: inherit;
        }

        /* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
        .page {
            page-break-after: always;
        }
    </style>

    <script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>

<body>
    <script>
        mermaid.initialize( {
            startOnLoad: true,
            theme: document.body.classList.contains( 'vscode-dark' ) || document.body.classList.contains( 'vscode-high-contrast' )
                ? 'dark'
                : 'default'
        } );
    </script>
    <h2 id="what-is-a-graph">What is a Graph?</h2>
    <p>A <strong>graph</strong> is <strong>any</strong> collection of nodes and edges. In contrast to our<br>
        previous trees, a graph is much more relaxed in it's structure. A graph may:</p>
    <ul>
        <li>lack a root node</li>
        <li>have cycles</li>
        <li>have any number edges leaving a node</li>
    </ul>


    <p><img src="file:///c:/Users/15512/Google Drive/a-A-September/00-weeks/week-8/notes/d3/bod/video-demo/images/graphs.png"
            alt="graphs"></p>
    <p>Here are some highlights:</p>
    <ul>
        <li><code>Graph 1</code> lacks a root. This means there is no single node that can access all<br>
            other nodes in a path through edges. This is important because we previously<br>
            referenced &quot;entire&quot; trees by referring to the ultimate root. We can no longer<br>
            do that in a graph. If we provide just <code>T</code>, you can't access <code>U</code>. If we<br>
            provide just <code>U</code>, you can't access <code>T</code>. If we provide just <code>V</code>, you
            can't<br>
            access <code>T</code> or <code>U</code>.</li>
        <li><code>Graph 2</code> has a cycle. This means there is no longer a parent-child<br>
            relationship. Choose any node in <code>Graph 2</code>, its grandchild will also be its<br>
            parent. Wait - what? From now on we'll have to use less specific language such<br>
            as &quot;<code>X</code> is a neighbor of <code>Y</code>.&quot; Perhaps even more deadly, imagine we ran
            a<br>
            &quot;simple&quot; Depth-First traversal on this graph. We could get trapped in an<br>
            infinite loop if we are not careful.</li>
        <li><code>Graph 3</code> features nodes that have more than 2 edges. Anarchy!</li>
    </ul>
    <h2 id="graph-implementations">Graph Implementations</h2>
    <p>There are many ways to represent a graph programmatically. Let's take a moment<br>
        to explore each and describe the tradeoffs we make when choosing among them. We<br>
        will use <code>Graph 3</code> from above as our candidate. Bear in mind that our graph is<br>
        directed. For example, this means that <code>C</code> can access <code>D</code>, but <code>D</code> cannot
        access<br>
        <code>C</code>.</p>
    <h3 id="graphnode-class">GraphNode Class</h3>
    <p>This implementation is most similar to how we implemented binary trees. That is,<br>
        we create a node class that maintains a value and an array of references to<br>
        neighboring nodes. This easily solves the problem that a node can have any<br>
        number of neighbors, no longer just a left and right.</p>
    <pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GraphNode</span> </span>{
    <span class="hljs-keyword">constructor</span>(val) {
        <span class="hljs-keyword">this</span>.val = val;
        <span class="hljs-keyword">this</span>.neighbors = [];
    }
}

<span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> GraphNode(<span class="hljs-string">'a'</span>);
<span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> GraphNode(<span class="hljs-string">'b'</span>);
<span class="hljs-keyword">let</span> c = <span class="hljs-keyword">new</span> GraphNode(<span class="hljs-string">'c'</span>);
<span class="hljs-keyword">let</span> d = <span class="hljs-keyword">new</span> GraphNode(<span class="hljs-string">'d'</span>);
<span class="hljs-keyword">let</span> e = <span class="hljs-keyword">new</span> GraphNode(<span class="hljs-string">'e'</span>);
<span class="hljs-keyword">let</span> f = <span class="hljs-keyword">new</span> GraphNode(<span class="hljs-string">'f'</span>);
a.neighbors = [b, c, e];
c.neighbors = [b, d];
e.neighbors = [a];
f.neighbors = [e];
</div></code></pre>
    <p>This implementation is great because it feels familiar to how we implemented<br>
        trees. However, this implementation is clunky in that we have no easy way to<br>
        refer to the entire graph. How can we pass this graph to a function? Recall that<br>
        there is no root to act as the definite starting point.</p>
    <h3 id="adjacency-matrix">Adjacency Matrix</h3>
    <p>This is the often the mathematician's preferred way of representing a graph. We<br>
        use a 2D array to represent edges. We'll first map each node's value to an<br>
        index. This means <code>A -&gt; 0</code>, <code>B -&gt; 1</code>, <code>C -&gt; 2</code>, etc.. Below is the
        mapping for<br>

    <p>From here, the row index will correspond to the source of an edge and the column<br>
        index will correspond to its destination. A value of <code>true</code> will mean that there<br>
        does exist an edge from source to destination.</p>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> matrix = [
<span class="hljs-comment">/*          A       B       C       D       E       F   */</span>
<span class="hljs-comment">/*A*/</span>    [<span class="hljs-literal">true</span>,  <span class="hljs-literal">true</span>,   <span class="hljs-literal">true</span>,   <span class="hljs-literal">false</span>,  <span class="hljs-literal">true</span>,   <span class="hljs-literal">false</span>],
<span class="hljs-comment">/*B*/</span>    [<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>,   <span class="hljs-literal">false</span>,  <span class="hljs-literal">false</span>,  <span class="hljs-literal">false</span>,  <span class="hljs-literal">false</span>],
<span class="hljs-comment">/*C*/</span>    [<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>,   <span class="hljs-literal">true</span>,   <span class="hljs-literal">true</span>,   <span class="hljs-literal">false</span>,  <span class="hljs-literal">false</span>],
<span class="hljs-comment">/*D*/</span>    [<span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>,  <span class="hljs-literal">false</span>,  <span class="hljs-literal">true</span>,   <span class="hljs-literal">false</span>,  <span class="hljs-literal">false</span>],
<span class="hljs-comment">/*E*/</span>    [<span class="hljs-literal">true</span>,  <span class="hljs-literal">false</span>,  <span class="hljs-literal">false</span>,  <span class="hljs-literal">false</span>,  <span class="hljs-literal">true</span>,   <span class="hljs-literal">false</span>],
<span class="hljs-comment">/*F*/</span>    [<span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>,  <span class="hljs-literal">false</span>,  <span class="hljs-literal">false</span>,  <span class="hljs-literal">true</span>,   <span class="hljs-literal">true</span>]
];
</div></code></pre>
    <p>A few things to note about using an adjacency matrix:</p>
    <ul>
        <li>when the edges have direction, <code>matrix[i][j]</code> may not be the same as<br>
            <code>matrix[j][i]</code></li>
        <li>it is common to say that a node is adjacent to itself, so <input type="checkbox" id="checkbox0"
                checked="true"><label for="checkbox0">=== true</label> for any <code>x</code></li>
    </ul>
    <p>An advantage of the matrix implementation is that it allows us to refer to the<br>
        entire graph by simply referring to the 2D array. A huge disadvantage of using a<br>
        matrix is the space required. To represent a graph of n nodes, we must allocate<br>
        n<sup>2</sup> space for the 2D array. This is even more upsetting when there are<br>
        few edges in graph. We will have to use n<sup>2</sup> space, even though the<br>
        array would be sparse with only a few <code>true</code> elements.</p>
    <h3 id="adjacency-list">Adjacency List</h3>
    <p>An adjacency list seeks to solve the shortcomings of the matrix implementation.<br>
        We use an object where keys represent the node labels. The values associated<br>
        with the keys will be an array containing all adjacent nodes:</p>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> graph = {
    <span class="hljs-string">'a'</span>: [<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'e'</span>],
    <span class="hljs-string">'b'</span>: [],
    <span class="hljs-string">'c'</span>: [<span class="hljs-string">'b'</span>, <span class="hljs-string">'d'</span>],
    <span class="hljs-string">'d'</span>: [],
    <span class="hljs-string">'e'</span>: [<span class="hljs-string">'a'</span>],
    <span class="hljs-string">'f'</span>: [<span class="hljs-string">'e'</span>]
};
</div></code></pre>
    <p>An adjacency list is easy to implement and allows us to refer to the entire<br>
        graph by simply referencing the object. The space required for an adjacency list<br>
        is the number of edges in the graph. Since there will be at most n<sup>2</sup><br>
        edges in a graph of n nodes, the adjacency list will use at most the same amount<br>
        of space as the matrix. You'll find adjacency lists useful when attacking<br>
        problems that are not explicitly about graphs. We'll elaborate more on this<br>
        soon.</p>
    <hr>
    <h1 id="graph-traversal">Graph Traversal</h1>
    <p>Let's explore our classic Depth-First, but for <strong>graphs</strong> this time! We'll be<br>
        utilizing the <code>GraphNode</code> and <code>Adjacency List</code> implementations of the following<br>
        graph:</p>
    <p><img src="file:///c:/Users/15512/Google Drive/a-A-September/00-weeks/week-8/notes/d3/bod/video-demo/graph.png"
            alt="graph"></p>
    <p>Since we already discussed the differences between Depth-First and<br>
        Breadth-First, we'll focus just on Depth-First here. We'll leave the<br>
        Breadth-First exploration in the upcoming project.</p>
    <h3 id="graph-traversal-w-graphnode">Graph Traversal w/ GraphNode</h3>
    <p>Let's begin by assuming we have our candidate graph implemented using our<br>
        <code>GraphNode</code> class:</p>
    <pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GraphNode</span> </span>{
    <span class="hljs-keyword">constructor</span>(val) {
        <span class="hljs-keyword">this</span>.val = val;
        <span class="hljs-keyword">this</span>.neighbors = [];
    }
}

<span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> GraphNode(<span class="hljs-string">'a'</span>);
<span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> GraphNode(<span class="hljs-string">'b'</span>);
<span class="hljs-keyword">let</span> c = <span class="hljs-keyword">new</span> GraphNode(<span class="hljs-string">'c'</span>);
<span class="hljs-keyword">let</span> d = <span class="hljs-keyword">new</span> GraphNode(<span class="hljs-string">'d'</span>);
<span class="hljs-keyword">let</span> e = <span class="hljs-keyword">new</span> GraphNode(<span class="hljs-string">'e'</span>);
<span class="hljs-keyword">let</span> f = <span class="hljs-keyword">new</span> GraphNode(<span class="hljs-string">'f'</span>);
a.neighbors = [e, c, b];
c.neighbors = [b, d];
e.neighbors = [a];
f.neighbors = [e];
</div></code></pre>
    <p>One thing we'll have to decide on is what node to begin our traversal. Depending<br>
        on the structure of the graph, there may not be a suitable starting point.<br>
        Remember that a graph may not have a &quot;root&quot;. However in our candidate, <code>F</code> is<br>
        like a root. It is the only valid choice because it is the only node that may<br>
        access all other nodes through some path of edges. We admit, the choice of <code>F</code><br>
        is somewhat contrived and in a practical setting you may not have a nice<br>
        starting point like this. We'll cover how to overcome this obstacle soon. For<br>
        now we'll take <code>F</code>.</p>
    <p>We want to build a recursive <code>depthFirstRecur</code> function that accepts a node and<br>
        performs a Depth-First traversal through the graph. Let's begin with a baseline<br>
        solution, although it is not yet complete to handle all graphs:</p>
    <pre class="hljs"><code><div><span class="hljs-comment">// broken</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">depthFirstRecur</span>(<span class="hljs-params">node</span>) </span>{
    <span class="hljs-built_in">console</span>.log(node.val);

    node.neighbors.forEach(<span class="hljs-function"><span class="hljs-params">neighbor</span> =&gt;</span> {
        depthFirstRecur(neighbor);
    });
}

depthFirstRecur(f);
</div></code></pre>
    <p>It will get caught in an infinite cycle<br>
        <code>f, e, a, e, a, e, a, e, ...</code> ! To fix this, simply store which nodes we have<br>
        visited already. Whenever we hit a node that has previously been visited, then<br>
        return early. We'll use JavaScript<br>
        <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set">Sets</a><br>
        to store <code>visited</code> because they allow for constant time lookup.</p>
    <pre class="hljs"><code><div><span class="hljs-comment">// using GraphNode representation</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">depthFirstRecur</span>(<span class="hljs-params">node, visited=new Set(</span>)) </span>{
    <span class="hljs-comment">// if this node has already been visited, then return early</span>
    <span class="hljs-keyword">if</span> (visited.has(node.val)) <span class="hljs-keyword">return</span>;

    <span class="hljs-comment">// otherwise it hasn't yet been visited,</span>
    <span class="hljs-comment">// so print it's val and mark it as visited.</span>
    <span class="hljs-built_in">console</span>.log(node.val);
    visited.add(node.val);

    <span class="hljs-comment">// then explore each of its neighbors</span>
    node.neighbors.forEach(<span class="hljs-function"><span class="hljs-params">neighbor</span> =&gt;</span> {
        depthFirstRecur(neighbor, visited);
    });
}

depthFirstRecur(f);
</div></code></pre>
    <p>This code works well and will print the values in the order <code>f, e, a, c, b, d</code>.<br>
        Note that this strategy only works if the values are guaranteed to be unique.</p>
    <p>If you are averse to recursion (don't be), we can write an iterative version<br>
        using the same principles:</p>
    <pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">depthFirstIter</span>(<span class="hljs-params">node</span>) </span>{
    <span class="hljs-keyword">let</span> visited = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
    <span class="hljs-keyword">let</span> stack = [ node ];

    <span class="hljs-keyword">while</span> (stack.length) {
        <span class="hljs-keyword">let</span> node = stack.pop();

        <span class="hljs-comment">// if this node has already been visited, then skip this node</span>
        <span class="hljs-keyword">if</span> (visited.has(node.val)) <span class="hljs-keyword">continue</span>;

        <span class="hljs-comment">// otherwise it hasn't yet been visited,</span>
        <span class="hljs-comment">// so print it's val and mark it as visited.</span>
        <span class="hljs-built_in">console</span>.log(node.val);
        visited.add(node.val);

        <span class="hljs-comment">// then add its neighbors to the stack to be explored</span>
        stack.push(...node.neighbors);
    }
}

depthFirstIter(f);
</div></code></pre>
    <h3 id="graph-traversal-w-adjacency-list">Graph Traversal w/ Adjacency List</h3>
    <p>Let's now assume our candidate graph in the form of an Adjacency List:</p>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> graph = {
    <span class="hljs-string">'a'</span>: [<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'e'</span>],
    <span class="hljs-string">'b'</span>: [],
    <span class="hljs-string">'c'</span>: [<span class="hljs-string">'b'</span>, <span class="hljs-string">'d'</span>],
    <span class="hljs-string">'d'</span>: [],
    <span class="hljs-string">'e'</span>: [<span class="hljs-string">'a'</span>],
    <span class="hljs-string">'f'</span>: [<span class="hljs-string">'e'</span>]
};
</div></code></pre>
    <p>Bear in mind that the nodes are just strings now, not <code>GraphNode</code>s. Other than<br>
        that, the code shares many details from our previous implementations:</p>
    <pre class="hljs"><code><div><span class="hljs-comment">// using Adjacency List representation</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">depthFirstRecur</span>(<span class="hljs-params">node, graph, visited=new Set(</span>)) </span>{
    <span class="hljs-keyword">if</span> (visited.has(node)) <span class="hljs-keyword">return</span>;

    <span class="hljs-built_in">console</span>.log(node);
    visited.add(node);

    graph[node].forEach(<span class="hljs-function"><span class="hljs-params">neighbor</span> =&gt;</span> {
        depthFirstRecur(neighbor, graph, visited);
    });
}

depthFirstRecur(<span class="hljs-string">'f'</span>, graph);
</div></code></pre>
    <p>Cool! We print values in the order <code>f, e, a, b, c, d</code>. We'll leave the iterative<br>
        version to you as an exercise for later.</p>
    <p>Instead, let's draw our attention to a point from before: having to choose <code>f</code><br>
        as the starting point isn't dynamic enough to be impressive. Also, if we choose<br>
        a poor initial node, some nodes may be unreachable. For example, choosing <code>a</code> as<br>
        the starting point with a call to <code>depthFirstRecur('a', graph)</code> will only print<br>
        <code>a, b, c, d, e</code>. We missed out on <code>f</code>. Bummer.</p>
    <p>We can fix this. A big advantage of using an Adjacency List is that it contains<br>
        the full graph! We can use a surrounding loop to allow our traversal to jump<br>
        between disconnected regions of the graph. Refactoring our code:</p>
    <pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">depthFirst</span>(<span class="hljs-params">graph</span>) </span>{
    <span class="hljs-keyword">let</span> visited = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> node <span class="hljs-keyword">in</span> graph) {
        _depthFirstRecur(node, graph, visited);
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_depthFirstRecur</span>(<span class="hljs-params">node, graph, visited</span>) </span>{
    <span class="hljs-keyword">if</span> (visited.has(node)) <span class="hljs-keyword">return</span>;

    <span class="hljs-built_in">console</span>.log(node);
    visited.add(node);

    graph[node].forEach(<span class="hljs-function"><span class="hljs-params">neighbor</span> =&gt;</span> {
        _depthFirstRecur(neighbor, graph, visited);
    });
}

depthFirst(graph);
</div></code></pre>
    <p>Notice that our main function <code>depthFirst</code> is iterative and accepts the entire<br>
        Adjacency List as an Argo. Our helper <code>_depthFirstRecur</code> is recursive.<br>
        <code>_depthFirstRecur</code> serves the same job as before, it will explore a full<br>
        connected region in a graph. The main <code>depthFirst</code> method will allow us to<br>
        &quot;bridge&quot; the gap between connection regions.</p>
    <p>Still fuzzy? Imagine we had the following graph. Before you ask, these are not<br>
        two separate graphs. This is a <strong>single</strong> graph that contains two connected<br>
        components. Another term for a graph of this structure is a &quot;Forest&quot; because it<br>
        contains multiple &quot;Trees&quot;, ha:</p>
    <p><img src="file:///c:/Users/15512/Google Drive/a-A-September/00-weeks/week-8/notes/d3/bod/video-demo/forest.png"
            alt="forest"></p>
    <p>It is easy to represent this graph using an Adjacency List. We can then pass the<br>
        graph into our <code>depthFirst</code> from above:</p>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> graph = {
    <span class="hljs-string">'h'</span>: [<span class="hljs-string">'i'</span>, <span class="hljs-string">'j'</span>],
    <span class="hljs-string">'i'</span>: [],
    <span class="hljs-string">'j'</span>: [<span class="hljs-string">'k'</span>],
    <span class="hljs-string">'k'</span>: [],
    <span class="hljs-string">'l'</span>: [<span class="hljs-string">'m'</span>],
    <span class="hljs-string">'m'</span>: []
}

depthFirst(graph);
<span class="hljs-comment">// prints h, i, j, k, l, m</span>
![](./../graph.png)
![](./../cycle.png)
![](./../path.png)
![](./../weighted-graph.png)
![](./../complete-or-connected-graph.png)
![](./../directed-graph.png)
DFS--&gt;   
![DFS](https:<span class="hljs-comment">//www3.cs.stonybrook.edu/~skiena/combinatorica/animations/anim/dfs.gif)</span>
![DFS](https:<span class="hljs-comment">//www.codesdope.com/staticroot/images/algorithm/dfs.gif)</span>

---
---

BFS--&gt;
![BFS](https:<span class="hljs-comment">//www3.cs.stonybrook.edu/~skiena/combinatorica/animations/anim/bfs.gif)</span>
![](https:<span class="hljs-comment">//codeabbey.github.io/data/breadth_first_search_1.gif)</span>
<span class="hljs-string">``</span><span class="hljs-string">`js
// class GraphNode {
//     constructor(val) {
//         this.val = val;
//         this.neighbors = [];
//     }
// }
//
// let a = new GraphNode("a");
// console.log('let a = new GraphNode("a"): ', a);
// let b = new GraphNode("b");
// let c = new GraphNode("c");
// console.log('let c = new GraphNode("c"): ', c);
// let d = new GraphNode("d");
// let e = new GraphNode("e");
// console.log('let e = new GraphNode("e"): ', e);
// let f = new GraphNode("f");
// console.log(
//     "------------------------------End of node instantions--------------------------------------"
// );
// console.log("a.neighbors = [e, c, b]: ", (a.neighbors = [e, c, b]));
//
// console.log("c.neighbors = [b, d]: ", (c.neighbors = [b, d]));
//
// console.log("e.neighbors = [a]: ", (e.neighbors = [a]));
//
// console.log("f.neighbors = [e]: ", (f.neighbors = [e]));
//
// console.log(
//     "------------------------------deapth first traversal (comment out adjacency list)--------------------------------------"
// );
//
// function depthFirstRecur(node, visited = new Set()) {
//     if (visited.has(node.val)) return;
//
//     console.log(node.val); //output
//     visited.add(node.val);
//
//     node.neighbors.forEach((neighbor) =&gt; {
//         depthFirstRecur(neighbor, visited);
//     });
// }
//
// //tree node class... if it didn't have a neighbours the value would be null but here it is just an empty array.
</span></div></code></pre>
    <h1 id="">&lt;=================()===============&gt;</h1>
    <pre class="hljs"><code><div>// Implementing a Graph in Code
// Similar to when working with other ADTs, we can crate a node class
// This class can have a property which will store all the nodes
// which this instance should hold reference to.
</div></code></pre>
    <pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GraphNode</span> </span>{
    <span class="hljs-keyword">constructor</span>(val) {
        <span class="hljs-keyword">this</span>.val = val;
        <span class="hljs-keyword">this</span>.neighbors = [];
    }
}
<span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> GraphNode(<span class="hljs-string">"a"</span>);
<span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> GraphNode(<span class="hljs-string">"b"</span>);
<span class="hljs-keyword">let</span> c = <span class="hljs-keyword">new</span> GraphNode(<span class="hljs-string">"c"</span>);
<span class="hljs-keyword">let</span> d = <span class="hljs-keyword">new</span> GraphNode(<span class="hljs-string">"d"</span>);
<span class="hljs-keyword">let</span> e = <span class="hljs-keyword">new</span> GraphNode(<span class="hljs-string">"e"</span>);
<span class="hljs-keyword">let</span> f = <span class="hljs-keyword">new</span> GraphNode(<span class="hljs-string">"f"</span>);
a.neighbors = [b, c, e];
c.neighbors = [b, d];
e.neighbors = [a];
f.neighbors = [e];
</div></code></pre>
    <p>// Adjacency Matrix<br>
        // The implementation above is considered rather clunky.<br>
        // We have no easy way to refer to the entire graph.<br>
        // Recall that there is no root to act as the definite starting point (unlike with Trees).<br>
        // How can we pass this graph to a function?<br>
        // One of the solutions is to create an Adjacency Matrix, a grid utilizing a 2D array.<br>
        // Matrix implementation allows us to refer to the entire graph by simply referring to the 2D array.<br>
        // The row index corresponds to the source of an edge.<br>
        // The column index will correspond to its destination.<br>
        // A value of true will mean that there does exist an edge from source to destination,<br>
        // ie, the source node should hold reference to destination node.</p>
    <pre class="hljs"><code><div>  - One axis (outside array) has an entry (inner array) <span class="hljs-keyword">for</span> each node <span class="hljs-keyword">in</span> the graph. If one node is connected to another node <span class="hljs-keyword">in</span> the graph, our entry <span class="hljs-keyword">in</span> the inner array is <span class="hljs-keyword">set</span> to true. Otherwise the entry is false.
let matrix = [
    /*  Destinations =&gt;     A/0     B/1     C/2     D/3     E/4     F/5   */
    /*  ----------------------------------------------------------------- */
    /*             | A/0 */ [true, true, true, false, true, false],
    /*             | B/1 */ [false, true, false, false, false, false],
    /* Sources =&gt;  | C/2 */ [false, true, true, true, false, false],
    /*             | D/3 */ [false, false, false, true, false, false],
    /*             | E/4 */ [true, false, false, false, true, false],
    /*             | F/5 */ [false, false, false, false, true, true],
];
</div></code></pre>
    <p>// Disadvantage:<br>
        // An adjacency matrix requires a lot of space.<br>
        // To represent a graph of n nodes, we must allocate n^2 space for the 2D array.<br>
        // If there are few edges in graph we will have to use n2 space,<br>
        // even though the array will only contain a few true elements.<br>
        // Adjacency List<br>
        // We use an object where keys represent the node labels.<br>
        // The values associated with the keys will be an array containing all<br>
        // adjacent nodes,<br>
        // ie, the nodes which this instance (represented by a key)<br>
        // should hold reference to.<br>
        // An adjacency list is easy to implement and allows us to refer to the<br>
        // entire graph by simply referencing the object.<br>
        // The space required for an adjacency list is the number of edges in<br>
        // the graph.</p>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> adjList = {
    <span class="hljs-attr">a</span>: [<span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>, <span class="hljs-string">"e"</span>],
    <span class="hljs-attr">b</span>: [],
    <span class="hljs-attr">c</span>: [<span class="hljs-string">"b"</span>, <span class="hljs-string">"d"</span>],
    <span class="hljs-attr">d</span>: [],
    <span class="hljs-attr">e</span>: [<span class="hljs-string">"a"</span>],
    <span class="hljs-attr">f</span>: [<span class="hljs-string">"e"</span>],
};
</div></code></pre>
    <p>// Recursive case given a node<br>
        function depthFirstNode(node, visited = new Set()) {<br>
        // We utilize a Set for our memo instead of a regular object<br>
        // A Set is like an object where the keys have no values<br>
        if (visited.has(node.val)) return;<br>
        console.log(node.val);<br>
        visited.add(node.val);<br>
        node.neighbors.forEach((neighbor) =&gt; depthFirstNode(neighbor, visited));<br>
        }<br>
        // We invoke this with an instance of the graph node class<br>
        // depthFirstNode(f);<br>
        // depthFirstNode(node, visited); // 1st frame, node.val = 'f', visited = {'f'}<br>
        // depthFirstNode(node, visited); // 2nd frame, node.val = 'e', visited = {'f', 'e'}<br>
        // depthFirstNode(node, visited); // 3rd frame, node.val = 'a', visited = {'f', 'e', 'a'}<br>
        // depthFirstNode(node, visited); // 4th frame, node.val = 'b', visited = {'f', 'e', 'a', 'b'}, popped off
        stack<br>
        // depthFirstNode(node, visited); // 5th frame, node.val = 'c', visited = {'f', 'e', 'a', 'b', 'c'}<br>
        // depthFirstNode(node, visited); // 6th frame, node.val = 'd', visited = {'f', 'e', 'a', 'b', 'c', 'd'}, popped
        off stack<br>
        // 5th frame, node.val = 'c' returns undefined, popped off the stack<br>
        // 4th frame, node.val = 'e' vistied.has(node.val) = true, returns undefined, popped off the stack<br>
        // 3rd frame, node.val = 'a' returns undefined, popped off the stack<br>
        // 2nd frame, node.val = 'e' returns undefined, popped off the stack<br>
        // 1st frame, node.val = 'f' returns undefined, popped off the stack<br>
        // Final return value: undefined<br>
        // Recursive case given an adjacency list</p>
    <pre class="hljs"><code><div><span class="hljs-comment">// let adjList = {</span>
<span class="hljs-comment">//   'a': ['b', 'c', 'e'],</span>
<span class="hljs-comment">//   'b': [],</span>
<span class="hljs-comment">//   'c': ['b', 'd'],</span>
<span class="hljs-comment">//   'd': [],</span>
<span class="hljs-comment">//   'e': ['a'],</span>
<span class="hljs-comment">//   'f': ['e'],</span>
<span class="hljs-comment">// };</span>
</div></code></pre>
    <pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">depthFirstAdj</span>(<span class="hljs-params">graph, node, visited = new Set(</span>)) </span>{
    <span class="hljs-comment">// if this node has already been visited, then return early</span>
    <span class="hljs-keyword">if</span> (visited.has(node)) <span class="hljs-keyword">return</span>;
    <span class="hljs-comment">// otherwise it hasn't yet been visited,</span>
    <span class="hljs-comment">// so print it's val and mark it as visited.</span>
    <span class="hljs-built_in">console</span>.log(node);
    visited.add(node);
    <span class="hljs-comment">// then explore each of its neighbors</span>
    graph[node].forEach(<span class="hljs-function">(<span class="hljs-params">neighbor</span>) =&gt;</span> {
        depthFirstAdj(graph, neighbor, visited);
    });
}
</div></code></pre>
    <p>// // We invoke this with the adjacency list and a key from the list.<br>
        // depthFirstAdj(adjList, 'f');<br>
        // console.log(<code>\n----------\n</code>);<br>
        // depthFirstAdj(adjList, 'a');<br>
        // We see that when we invoke this function with 'a' we are not able to access the 'f' node</p>
    <pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">completeDepthFirst</span>(<span class="hljs-params">graph</span>) </span>{
    <span class="hljs-keyword">let</span> visited = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> node <span class="hljs-keyword">in</span> graph) {
        _depthFirstRecur(node, graph, visited);
    }
}
</div></code></pre>
    <pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_depthFirstRecur</span>(<span class="hljs-params">node, graph, visited</span>) </span>{
    <span class="hljs-comment">// if this node has already been visited, then return early</span>
    <span class="hljs-keyword">if</span> (visited.has(node)) <span class="hljs-keyword">return</span>;
    <span class="hljs-comment">// otherwise it hasn't yet been visited,</span>
    <span class="hljs-comment">// so print it's val and mark it as visited.</span>
    <span class="hljs-built_in">console</span>.log(node);
    visited.add(node);
    <span class="hljs-comment">// then explore each of its neighbors</span>
    graph[node].forEach(<span class="hljs-function">(<span class="hljs-params">neighbor</span>) =&gt;</span> {
        _depthFirstRecur(neighbor, graph, visited);
    });
}
<span class="hljs-comment">// We invoke this with the adjacency list and a key from the list.</span>
completeDepthFirst(adjList, <span class="hljs-string">"f"</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`\n----------\n`</span>);
completeDepthFirst(adjList, <span class="hljs-string">"a"</span>);
</div></code></pre>
    <ul>
        <li>Adjacency List - POJO
            <ul>
                <li>Object where every value in the graph has a key</li>
                <li>Value for the key is an array with each other node that it is connected to (neighbors)</li>
                <li>Easy to iterate through</li>
                <li>Doesn't take up as much space as an Adjacency Matrix or Node</li>
                <li>Can refer to the entire graph by referencing the object</li>
            </ul>
            <pre class="hljs"><code><div>  <span class="hljs-keyword">let</span> list = {
    <span class="hljs-attr">a</span>: [<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'e'</span>],
    <span class="hljs-attr">b</span>: [],
    <span class="hljs-attr">c</span>: [<span class="hljs-string">'b'</span>, <span class="hljs-string">'d'</span>],
    <span class="hljs-attr">d</span>: [],
    <span class="hljs-attr">e</span>: [<span class="hljs-string">'a'</span>],
    <span class="hljs-attr">f</span>: [<span class="hljs-string">'e'</span>]
  };
</div></code></pre>
        </li>
    </ul>
    <pre class="hljs"><code><div> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GraphNode</span> </span>{
    <span class="hljs-keyword">constructor</span>(val) {
      <span class="hljs-keyword">this</span>.val = val;
      <span class="hljs-keyword">this</span>.neighbors = [];
    }
  }
</div></code></pre>
    <ol start="3">
        <li>Given a graph in one of the above implementations, be able to traverse the graph in a breadth-first or
            depth-first manner.</li>
    </ol>
    <ul>
        <li>We can use recursion or iteration to traverse each node.</li>
        <li>We generally want to keep track of each node that we've visited already so that we don't get trapped in
            cycles. Easiest way to do this is to keep a Set variable that we update as we traverse to each node.</li>
    </ul>
    <h2 id="graph">Graph</h2>
    <p><img src="https://storage.googleapis.com/algodailyrandomassets/curriculum/cheatsheet/graph.png" alt=""></p>
    <ul>
        <li><strong>Quick summary</strong>: a data structure that stores items in a connected, non-hierarchical network.
        </li>
        <li><strong>Important facts</strong>:
            <ul>
                <li>Each graph element is called a <em>node</em>, or <em>vertex</em>.</li>
                <li>Graph nodes are connected by <em>edges</em>.</li>
                <li>Graphs can be <em>directed</em> or <em>undirected</em>.</li>
                <li>Graphs can be <em>cyclic</em> or <em>acyclic</em>. A cyclic graph contains a path from at least one
                    node back to itself.</li>
                <li>Graphs can be <em>weighted</em> or <em>unweighted</em>. In a weighted graph, each edge has a certain
                    numerical weight.</li>
                <li>Graphs can be <em>traversed</em>. See important facts under <em>Tree</em> for an overview of
                    traversal algorithms.</li>
                <li>Data structures used to represent graphs:
                    <ul>
                        <li><em>Edge list</em>: a list of all graph edges represented by pairs of nodes that these edges
                            connect.</li>
                        <li><em>Adjacency list</em>: a list or hash table where a key represents a node and its value
                            represents the list of this node's neighbors.</li>
                        <li><em>Adjacency matrix</em>: a matrix of binary values indicating whether any two nodes are
                            connected.</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li><strong>Pros</strong>:
            <ul>
                <li>Ideal for representing entities interconnected with links.</li>
            </ul>
        </li>
        <li><strong>Cons</strong>:
            <ul>
                <li>Low performance makes scaling hard.</li>
            </ul>
        </li>
        <li><strong>Notable uses</strong>:
            <ul>
                <li>Social media networks.</li>
                <li>Recommendations in ecommerce websites.</li>
                <li>Mapping services.</li>
            </ul>
        </li>
        <li><strong>Time complexity</strong> (worst case): varies depending on the choice of algorithm.
            <code>O(n*lg(n))</code> or slower for most graph algorithms.</li>
    </ul>
    <h1 id="graph-data-structure-cheat-sheet-for-coding-interviews">Graph data structure cheat sheet for coding
        interviews.</h1>
    <blockquote>
        <p>Covering algorithms: BFS, DFS, detect cycle and find the shortest path</p>
    </blockquote>
    <p>The most commonly used representations of a graph are adjacency matrix (a 2D array of size V x V where V is the
        number of vertices in a graph) and adjacency list (an array of lists represents the list of vertices adjacent to
        each vertex).</p>
    <p>In the following sections, let's take a look must-to-know algorithms related to graph data structure. For
        simplicity, adjacency list representation is used in all the implementation.</p>
    <h2 id="1-breadth-first-search-bfs">1. Breadth First Search (BFS)</h2>
    <pre class="hljs"><code><div>`Input (graph 1): graph = \[\[1,2\], \[0,2,4\], \[0,1,3\], \[2\], \[1\]\], s = 0  
Output: **0 1 2 4 3**`

</div></code></pre>
    <p>Breadth First Search for a graph is similar to <a
            href="https://medium.com/@nhudinhtuan/binary-tree-traversals-cheat-sheet-for-coding-interviews-a71af9fe1dba">Breadth
            First Traversal of a tree</a>. However, graphs may contain cycles, so we may visit the same vertex again and
        again. To avoid that, we can use boolean visited array to mark the visited vertices.</p>
    <p>The above code traverses only the vertices reachable from a given source vertex. To do complete BFS traversal for
        disconnected graphs, we need to call BFS for every vertex.</p>
    <p>Time complexity is O(V+E) where V is number of vertices in the graph and E is number of edges in the graph.</p>
    <h2 id="2-depth-first-search-dfs">2. Depth First Search (DFS)</h2>
    <pre class="hljs"><code><div>_Input (graph 1): graph = \[\[1,2\], \[0,2,4\], \[0,1,3\], \[2\], \[1\]\], s = 0  
Output: **0 1 2 3 4 (or 0 2 3 1 4)**_

</div></code></pre>
    <p>Similar to BFS, we also need to use a boolean array to mark the visited vertices for DFS.</p>
    <p>Recursive implementation:</p>
    <p>Iterative implementation using stack. Please note that the stack may <em>contain the same vertex twice,</em> so
        we need to check the visited set before printing.</p>
    <p>For both implementations, all the vertices may not be reachable from a given vertex (example Disconnected graph).
        To do complete DFS traversal, we need to call DFS for every vertex.</p>
    <p>Time complexity is O(V+E) where V is the number of vertices in the graph and E is number of edges in the graph.
    </p>
    <h2 id="3-detect-cycle-in-directed-graph">3. Detect cycle in directed graph</h2>
    <pre class="hljs"><code><div>`Given a **directed** graph, return true if the given graph contains at least one cycle, else return false.
Input (graph 2): graph = \[\[1,2\], \[2\], \[0,3\], \[\], \[1\]\]  
Output: **True**`

</div></code></pre>
    <p>DFS can be used to detect a cycle in a Graph. There is a cycle in a graph only if there is a back edge that is
        from a vertex to itself (self-loop) or to one of its ancestor in DFS stack tree.</p>
    <p>Time complexity is the same as the normal DFS, which is O(V+E).</p>
    <h2 id="4-detect-cycle-in-undirected-graph">4. Detect cycle in undirected graph</h2>
    <p>Given an <strong>undirected</strong> graph, return true if the given graph contains at least one cycle,<br>
        else return false.Input (graph 1): graph = [[1,2], [0,2,4], [0,1,3], [2], [1]]<br>
        Output: <strong>True</strong></p>
    <p>For undirected graph, we don't need to keep track of the whole stack tree (compared to directed graph cases). For
        every vertex 'v', if there is an adjacent 'u' such that u is already visited and u is not a parent of v, then
        there is a cycle in the graph.</p>
    <p>Time complexity is the same as the normal DFS, which is O(V+E).</p>
    <h2 id="5-bfs-with-multiple-sources">5. BFS with multiple sources</h2>
    <p>In some problems, you need to start BFS for multiple vertices as well as calculate the travel depth. Let's take a
        look at a typical problem.</p>
    <p><img src="https://miro.medium.com/max/3442/1*_l111oYuT3XcwqfhuQ2Mdg.jpeg" alt="Image for post"></p>
    <p>In this question, we use a BFS to model the process. The grid is considered as a graph (an orange cell is a
        vertex and there are edges to the cell's neighbours). Starting BFS from all rotten oranges with 'depth' 0, and
        then travel to their neighbours which have 1 more depth. At the end, if we still have unvisited oranges, return
        -1 as this is impossible to rotten all oranges.</p>
    <p>Time complexity is O(V+E) = O(the number of cells in grid).</p>
    <h2 id="6-topological-sort">6. Topological sort</h2>
    <p>Topological sorting is a linear ordering of vertices such that for every directed edge uv, vertex u comes before
        v in the ordering. Topological sorting is only possible for <a
            href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">Directed Acyclic Graph (DAG)</a>.</p>
    <p><img src="https://miro.medium.com/max/2402/1*kXXJJRWrD6vhdDqc6RnEtA.jpeg" alt="Image for post"></p>
    <p>Given a <strong>DAG</strong>, return the topological sortingInput: graph = [[1,2], [2], [3], [], [1]]<br>
        Output: <strong>4 0 1 2 3</strong></p>
    <p>In normal DFS, we print the vertex at the beginning of the recursive function. To find the topological sorting,
        we modify DFS to make it first recursively call for all its adjacent vertices, then push its value to a stack.
        At the end, we print out the stack.</p>
    <p>Time complexity is the same as the normal DFS, which is O(V+E).</p>
    <h2 id="7-shortest-path-in-an-unweighted-graph">7. Shortest path in an unweighted graph</h2>
    <p>Given a unweighted graph, a source and a destination, we need to find shortest path from source to
        destination.Input (graph 1): graph = [[1,2], [0,2,4], [0,1,3], [2], [1]], s=4, d=0<br>
        Output: <strong>4 1 0</strong>Input (graph 2): graph = [[1,2], [2], [0, 3], [], [1]], s=1, d=0<br>
        Output: <strong>1 2 0</strong></p>
    <p>For this question, we use BFS and keep storing the predecessor of a given vertex while doing the breadth first
        search. At the end, we use the predecessor array to print the path.</p>
    <p>Time complexity is the same as normal BFS, which is O(V+E).</p>
    <h2 id="7-shortest-path-in-a-weighted-graph">7. Shortest path in a weighted graph</h2>
    <p>Given a graph and a source vertex in graph, find shortest distances from source to all vertices in the given
        graph.Input: graph = [[[1, 2], [2, 6]], [[2, 1]], [[0, 1], [3, 3]], [], [[1, 1]]], s=0<br>
        Output: <strong>[0, 2, 3, 6, inf]</strong></p>
    <p><img src="https://miro.medium.com/max/3126/1*TPDkarMgeeG5kRf8z1NxTA.jpeg" alt="Image for post"></p>

</body>

</html>
