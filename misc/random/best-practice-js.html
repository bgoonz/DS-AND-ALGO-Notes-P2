<!doctype html>
<html>
<head>
<meta charset="utf-8">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/3.0.1/github-markdown.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.18.1/lib/index.min.js">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markdown-it-texmath@0.6.5/css/texmath.css">
<link rel="stylesheet" href="https://gitcdn.xyz/repo/goessner/mdmath/master/css/vscode-texmath.css">

</head>
<body class="markdown-body">
<p align="center">
  <img src="https://i.pinimg.com/originals/18/e0/64/18e0641748101b3f7275f5723d4405f0.gif" />
</p>
<hr>
<a for="toc-anchor" id="%3Cspan-style%3D%22font-family%3Apapyrus%3B-font-size%3A1em%3B-color%3A-%233333ff%22%3E%3Ccenter%3Ejs--best-practices-%26-tools%3C%2Fcenter%3E-%3Cspan-style%3D%22color%3A-%2333ccff%22%3E%3Ccenter%3E(%3Acomputer%3Arunning-list%3Afloppy_disk%3A)%3C%2Fcenter%3E%3C%2Fspan%3E"></a><h1 id="centerjs--best-practices--toolscenter-span-stylecolor-33ccffcenterrunning-listcenter-37"><span style="font-family:Papyrus; font-size:1em; color: #3333ff"><center>JS- BEST PRACTICES &amp; TOOLS</center> <span style="color: #33ccff"><center>(💻Running List💾)</center></span></h1>
<hr>
<p align="center">
  <img src="https://thumbs.gfycat.com/CriminalKnobbyHind-small.gif" />
</p>
<center>
<p><a href="#variables">Variables</a>
<a href="#functions">Functions</a>
<a href="#objects-and-data-structures">Objects and Data Structures</a>
<a href="#classes">Classes</a>
<a href="#solid">SOLID</a>
<a href="#testing">Testing</a>
<a href="#concurrency">Concurrency</a>
<a href="#error-handling">Error Handling</a>
<a href="#formatting">Formatting</a>
<a href="#comments">Comments</a>
<a href="#translation">Translation</a></p>
<div class="">
</div>
<p><a href="#about">ABOUT</a>
<a href="#currentversion">CURRENT VERSION</a>
<a href="#thedom">THE DOM</a>
<a href="#conventions">Conventions</a>
<a href="#linting">Linting</a>
<a href="#objectoriented">Object Oriented</a>
<a href="#anonymousfunctions">Anonymous Functions</a>
<a href="#functionsasfirstclassobjects">Functions as Firstclass Objects</a>
<a href="#loosetyping">Loose Typing</a>
<a href="#scopingandhoisting">Scoping and Hoisting</a>
<a href="#functionbinding">Function Binding</a>
<a href="#closurefunction">Closure Function</a>
<a href="#strictmode">Strict mode</a>
<a href="#immediatelyinvokedfunctionexpressioniife">ImmediatelyInvoked Function Expression (IIFE)</a>
<a href="#arindampauljavascriptvminternalseventloopasyncandscopechains">Arindam Paul  JavaScript VM internals, EventLoop, Async and ScopeChains</a>
<a href="#generalpurpose">GENERAL PURPOSE</a>
<a href="#mv">MV*</a>
<a href="#library">Library</a>
<a href="#animation">Animation</a></p>
<div class="">
</div>
<p><a href="#the16javascriptdebuggingtips">The 16 JavaScript debugging tips</a>
<a href="#debugjavascriptfaster">Debug JavaScript faster</a>
<a href="#1debugger">1. debugger</a>
<a href="#2displayobjectsasatable">2. Display objects as a table</a>
<a href="#3tryallthesizes">3. Try all the sizes</a>
<a href="#4howtofindyourdomelementsquickly">4. How to find your DOM elements quickly</a>
<a href="#5benchmarkloopsusingconsoletimeandconsoletimeend">5. Benchmark loops using console.time() and console.timeEnd()</a>
<a href="#6getthestacktraceforafunction">6. Get the stack trace for a function</a>
<a href="#7unminifycodeasaneasywaytodebugjavascript">7. Unminify code as an easy way to debug JavaScript</a>
<a href="#8quickfindafunctiontodebug">8. Quickfind a function to debug</a>
<a href="#9blackboxscriptsthatarenotrelevant">9. Black box scripts that are NOT relevant</a>
<a href="#10findtheimportantthingsincomplexdebugging">10. Find the important things in complex debugging</a>
<a href="#11watchspecificfunctioncallsandarguments">11. Watch specific function calls and arguments</a>
<a href="#12quicklyaccesselementsintheconsole">12. Quickly access elements in the console</a>
<a href="#13postmanisgreatbutfirefoxisfaster">13. Postman is great (but Firefox is faster)</a>
<a href="#14breakonnodechange">14. Break on node change</a>
<a href="#15usepagespeedservices">15. Use page speed services</a>
<a href="#16breakpointseverywhere">16. Breakpoints everywhere</a></p>
<div class="">
</div>
<p><a href="#tools">TOOLS</a>
<a href="#thebestjavascriptdebuggingtoolsfor2020andbeyond">The best JavaScript debugging tools for 2020 and beyond</a>
<a href="#1developertoolsinmodernwebbrowsers">1. Developer tools in modern web browsers</a>
<a href="#chromedevelopertools">Chrome developer tools</a>
<a href="#reactdevelopertoolsforchrome">React developer tools for Chrome</a>
<a href="#firefoxdevelopertools">Firefox developer tools</a>
<a href="#safaridevelopmenu">Safari Develop Menu</a>
<a href="#blockquoteoperachromiumdevtoolsblockquote">&gt;Opera Chromium dev tools&gt;</a>
<a href="#blockquoteedgedevelopertoolsblockquote">&gt;Edge Developer Tools&gt;</a>
<a href="#2thehackabledebugtooldebugger">2. The hackable debug tool — debugger</a>
<a href="#3nodejsinspectorfordebuggingrequeststonodeapps">3. Node.js Inspector for debugging requests to Node apps</a>
<a href="#4postmanfordebuggingrequestsandresponses">4. Postman for debugging requests and responses</a>
<a href="#5eslint">5. ESLint</a>
<a href="#6jsbin">6. JS Bin</a>
<a href="#7jsonformatterandvalidator">7. JSON Formatter and Validator</a>
<a href="#8webpack">8. Webpack</a>
<a href="#9sessionstack">9. SessionStack</a>
<a href="#10raygunerrormonitoring">10. Raygun Error Monitoring</a></p>
</center>
<a for="toc-anchor" id="adapted-from%3A-robert-c.-martin's-book-clean-code"></a><h3 id="adapted-from-robert-c-martins-book-clean-code-44">Adapted From: Robert C. Martin's book Clean Code</h3>
<a for="toc-anchor" id="and"></a><h2 id="and-137">and</h2>
<p><u><a href="https://github.com/ryanmcdermott/clean-code-javascript">github repo Clean Code Javascript</a></u></p>
<a for="toc-anchor" id="and"></a><h2 id="and-138">and</h2>
<p><u><a href="https://github.com/getify/You-Dont-Know-JS.git">you don't know javascript</a></u></p>
<a for="toc-anchor" id="and"></a><h2 id="and-139">and</h2>
<p><u><a href="https://raygun.com/learn/javascript-debugging-tips">raygun</a></u></p>
<a for="toc-anchor" id="and"></a><h2 id="and-140">and</h2>
<p><u><a href="https://jstherightway.org/">JavaScript The Right Way</a></u></p>
<p align="center">
  <img src="https://res.cloudinary.com/practicaldev/image/fetch/s--ZDtqrBOj--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://github.com/damiancipolat/js_vs_memes/blob/master/doc/js_thanks.png%3Fraw%3Dtrue" />
</p>
<hr>
<hr>
<hr>
<a for="toc-anchor" id="%3Evariables%3E"></a><h2 id="blockquotevariablesblockquote-8">&gt;Variables&gt;</h2>
<hr>
<hr>
<a for="toc-anchor" id="use-meaningful-and-pronounceable-variable-names"></a><h2 id="use-meaningful-and-pronounceable-variable-names-178">Use meaningful and pronounceable variable names</h2>
<hr>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-keyword">const</span> yyyymmdstr = moment().format(<span class="hljs-string">"YYYY/MM/DD"</span>);
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-keyword">const</span> currentDate = moment().format(<span class="hljs-string">"YYYY/MM/DD"</span>);
</div></code></pre>
<hr>
<a for="toc-anchor" id="use-the-same-vocabulary-for-the-same-type-of-variable"></a><h2 id="use-the-same-vocabulary-for-the-same-type-of-variable-177">Use the same vocabulary for the same type of variable</h2>
<hr>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div>getUserInfo();
getClientData();
getCustomerRecord();
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div>getUser();
</div></code></pre>
<hr>
<a for="toc-anchor" id="use-searchable-names"></a><h2 id="use-searchable-names-54">Use searchable names</h2>
<p>We will read more code than we will ever write. It's important that the code we
do write is readable and searchable. By <u>not</u> naming variables that end up
being meaningful for understanding our program, we hurt our readers.
Make your names searchable. Tools like
<a href="https://github.com/danielstjules/buddy.js">buddy.js</a> and
<a href="https://github.com/eslint/eslint/blob/660e0918933e6e7fede26bc675a0763a6b357c94/docs/rules/no-magic-numbers.md">ESLint</a>
can help identify unnamed constants.</p>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-comment">// What the heck is 86400000 for?</span>
setTimeout(blastOff, <span class="hljs-number">86400000</span>);
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-comment">// Declare them as capitalized named constants.</span>
<span class="hljs-keyword">const</span> MILLISECONDS_IN_A_DAY = <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> * <span class="hljs-number">1000</span>; <span class="hljs-comment">//86400000;</span>

setTimeout(blastOff, MILLISECONDS_IN_A_DAY);
</div></code></pre>
<hr>
<a for="toc-anchor" id="use-explanatory-variables"></a><h2 id="use-explanatory-variables-51">Use explanatory variables</h2>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-keyword">const</span> address = <span class="hljs-string">"One Infinite Loop, Cupertino 95014"</span>;
<span class="hljs-keyword">const</span> cityZipCodeRegex = <span class="hljs-regexp">/^[^,\\]+[,\\\s]+(.+?)\s*(\d{5})?$/</span>;
saveCityZipCode(
    address.match(cityZipCodeRegex)[<span class="hljs-number">1</span>],
    address.match(cityZipCodeRegex)[<span class="hljs-number">2</span>]
);
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-keyword">const</span> address = <span class="hljs-string">"One Infinite Loop, Cupertino 95014"</span>;
<span class="hljs-keyword">const</span> cityZipCodeRegex = <span class="hljs-regexp">/^[^,\\]+[,\\\s]+(.+?)\s*(\d{5})?$/</span>;
<span class="hljs-keyword">const</span> [_, city, zipCode] = address.match(cityZipCodeRegex) || [];
saveCityZipCode(city, zipCode);
</div></code></pre>
<hr>
<a for="toc-anchor" id="avoid-mental-mapping"></a><h2 id="avoid-mental-mapping-53">Avoid Mental Mapping</h2>
<p>Explicit is better than implicit.</p>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-keyword">const</span> locations = [<span class="hljs-string">"Austin"</span>, <span class="hljs-string">"New York"</span>, <span class="hljs-string">"San Francisco"</span>];
locations.forEach(<span class="hljs-function"><span class="hljs-params">l</span> =&gt;</span> {
    doStuff();
    doSomeOtherStuff();
    <span class="hljs-comment">// ...</span>
    <span class="hljs-comment">// ...</span>
    <span class="hljs-comment">// ...</span>
    <span class="hljs-comment">// Wait, what is `l` for again?</span>
    dispatch(l);
});
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-keyword">const</span> locations = [<span class="hljs-string">"Austin"</span>, <span class="hljs-string">"New York"</span>, <span class="hljs-string">"San Francisco"</span>];
locations.forEach(<span class="hljs-function"><span class="hljs-params">location</span> =&gt;</span> {
    doStuff();
    doSomeOtherStuff();
    <span class="hljs-comment">// ...</span>
    <span class="hljs-comment">// ...</span>
    <span class="hljs-comment">// ...</span>
    dispatch(location);
});
</div></code></pre>
<hr>
<a for="toc-anchor" id="don't-add-unneeded-context"></a><h2 id="dont-add-unneeded-context-51">Don't add unneeded context</h2>
<p>If your class/object name tells you something, don't repeat that in your
variable name.</p>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-keyword">const</span> Car = {
    <span class="hljs-attr">carMake</span>: <span class="hljs-string">"Honda"</span>,
    <span class="hljs-attr">carModel</span>: <span class="hljs-string">"Accord"</span>,
    <span class="hljs-attr">carColor</span>: <span class="hljs-string">"Blue"</span>
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">paintCar</span>(<span class="hljs-params">car</span>) </span>{
    car.carColor = <span class="hljs-string">"Red"</span>;
}
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-keyword">const</span> Car = {
    <span class="hljs-attr">make</span>: <span class="hljs-string">"Honda"</span>,
    <span class="hljs-attr">model</span>: <span class="hljs-string">"Accord"</span>,
    <span class="hljs-attr">color</span>: <span class="hljs-string">"Blue"</span>
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">paintCar</span>(<span class="hljs-params">car</span>) </span>{
    car.color = <span class="hljs-string">"Red"</span>;
}
</div></code></pre>
<hr>
<a for="toc-anchor" id="use-default-arguments-instead-of-short-circuiting-or-conditionals"></a><h2 id="use-default-arguments-instead-of-short-circuiting-or-conditionals-51">Use default arguments instead of short circuiting or conditionals</h2>
<p>Default arguments are often cleaner than short circuiting. Be aware that if you
use them, your function will only provide default values for <code>undefined</code>
arguments. Other &quot;falsy&quot; values such as <code>''</code> , <code>&quot;&quot;</code> , <code>false</code> , <code>null</code> , <code>0</code> , and
<code>NaN</code> , will not be replaced by a default value.</p>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createMicrobrewery</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">const</span> breweryName = name || <span class="hljs-string">"Hipster Brew Co."</span>;
    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createMicrobrewery</span>(<span class="hljs-params">name = <span class="hljs-string">"Hipster Brew Co."</span></span>) </span>{
    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<a for="toc-anchor" id="%3Efunctions%3E"></a><h2 id="blockquotefunctionsblockquote-8">&gt;Functions&gt;</h2>
<hr>
<a for="toc-anchor" id="function-arguments-(2-or-fewer-ideally)"></a><h2 id="function-arguments-2-or-fewer-ideally-51">Function arguments (2 or fewer ideally)</h2>
<p>Limiting the amount of function parameters is incredibly important because it
makes testing your function easier. Having more than three leads to a
combinatorial explosion where you have to test tons of different cases with
each separate argument.</p>
<p>One or two arguments is the ideal case, and three should be avoided if possible.
Anything more than that should be consolidated. Usually, if you have
more than two arguments then your function is trying to do too much. In cases
where it's not, most of the time a higher-level object will suffice as an
argument.</p>
<p>Since JavaScript allows you to make objects on the fly, without a lot of class
boilerplate, you can use an object if you are finding yourself needing a
lot of arguments.</p>
<p>To make it obvious what properties the function expects, you can use the ES2015/ES6
destructuring syntax. This has a few advantages:</p>
<ol>
<li>When someone looks at the function signature, it's immediately clear what</li>
</ol>
<p>properties are being used.</p>
<ol start="2">
<li>It can be used to simulate named parameters.</li>
<li>Destructuring also clones the specified primitive values of the argument</li>
</ol>
<p>object passed into the function. This can help prevent side effects. Note:
objects and arrays that are destructured from the argument object are NOT
cloned.</p>
<ol start="4">
<li>Linters can warn you about unused properties, which would be impossible</li>
</ol>
<p>without destructuring.</p>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createMenu</span>(<span class="hljs-params">title, body, buttonText, cancellable</span>) </span>{
    <span class="hljs-comment">// ...</span>
}

createMenu(<span class="hljs-string">"Foo"</span>, <span class="hljs-string">"Bar"</span>, <span class="hljs-string">"Baz"</span>, <span class="hljs-literal">true</span>);
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createMenu</span>(<span class="hljs-params">{
    title,
    body,
    buttonText,
    cancellable
}</span>) </span>{
    <span class="hljs-comment">// ...</span>
}

createMenu({
    <span class="hljs-attr">title</span>: <span class="hljs-string">"Foo"</span>,
    <span class="hljs-attr">body</span>: <span class="hljs-string">"Bar"</span>,
    <span class="hljs-attr">buttonText</span>: <span class="hljs-string">"Baz"</span>,
    <span class="hljs-attr">cancellable</span>: <span class="hljs-literal">true</span>
});
</div></code></pre>
<hr>
<a for="toc-anchor" id="functions-should-do-one-thing"></a><h2 id="functions-should-do-one-thing-51">Functions should do one thing</h2>
<p>This is by far the most important rule in software engineering. When functions
do more than one thing, they are harder to compose, test, and reason about.
When you can isolate a function to just one action, it can be refactored
easily and your code will read much cleaner. If you take nothing else away from
this guide other than this, you'll be ahead of many developers.</p>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">emailClients</span>(<span class="hljs-params">clients</span>) </span>{
    clients.forEach(<span class="hljs-function"><span class="hljs-params">client</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> clientRecord = database.lookup(client);
        <span class="hljs-keyword">if</span> (clientRecord.isActive()) {
            email(client);
        }
    });
}
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">emailActiveClients</span>(<span class="hljs-params">clients</span>) </span>{
    clients.filter(isActiveClient).forEach(email);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isActiveClient</span>(<span class="hljs-params">client</span>) </span>{
    <span class="hljs-keyword">const</span> clientRecord = database.lookup(client);
    <span class="hljs-keyword">return</span> clientRecord.isActive();
}
</div></code></pre>
<hr>
<a for="toc-anchor" id="function-names-should-say-what-they-do"></a><h2 id="function-names-should-say-what-they-do-51">Function names should say what they do</h2>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addToDate</span>(<span class="hljs-params">date, month</span>) </span>{
    <span class="hljs-comment">// ...</span>
}

<span class="hljs-keyword">const</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();

<span class="hljs-comment">// It's hard to tell from the function name what is added</span>
addToDate(date, <span class="hljs-number">1</span>);
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addMonthToDate</span>(<span class="hljs-params">month, date</span>) </span>{
    <span class="hljs-comment">// ...</span>
}

<span class="hljs-keyword">const</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
addMonthToDate(<span class="hljs-number">1</span>, date);
</div></code></pre>
<hr>
<a for="toc-anchor" id="functions-should-only-be-one-level-of-abstraction"></a><h2 id="functions-should-only-be-one-level-of-abstraction-51">Functions should only be one level of abstraction</h2>
<p>When you have more than one level of abstraction your function is usually
doing too much. Splitting up functions leads to reusability and easier
testing.</p>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseBetterJSAlternative</span>(<span class="hljs-params">code</span>) </span>{
    <span class="hljs-keyword">const</span> REGEXES = [
        <span class="hljs-comment">// ...</span>
    ];

    <span class="hljs-keyword">const</span> statements = code.split(<span class="hljs-string">" "</span>);
    <span class="hljs-keyword">const</span> tokens = [];
    REGEXES.forEach(<span class="hljs-function"><span class="hljs-params">REGEX</span> =&gt;</span> {
        statements.forEach(<span class="hljs-function"><span class="hljs-params">statement</span> =&gt;</span> {
            <span class="hljs-comment">// ...</span>
        });
    });

    <span class="hljs-keyword">const</span> ast = [];
    tokens.forEach(<span class="hljs-function"><span class="hljs-params">token</span> =&gt;</span> {
        <span class="hljs-comment">// lex...</span>
    });

    ast.forEach(<span class="hljs-function"><span class="hljs-params">node</span> =&gt;</span> {
        <span class="hljs-comment">// parse...</span>
    });
}
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseBetterJSAlternative</span>(<span class="hljs-params">code</span>) </span>{
    <span class="hljs-keyword">const</span> tokens = tokenize(code);
    <span class="hljs-keyword">const</span> syntaxTree = parse(tokens);
    syntaxTree.forEach(<span class="hljs-function"><span class="hljs-params">node</span> =&gt;</span> {
        <span class="hljs-comment">// parse...</span>
    });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tokenize</span>(<span class="hljs-params">code</span>) </span>{
    <span class="hljs-keyword">const</span> REGEXES = [
        <span class="hljs-comment">// ...</span>
    ];

    <span class="hljs-keyword">const</span> statements = code.split(<span class="hljs-string">" "</span>);
    <span class="hljs-keyword">const</span> tokens = [];
    REGEXES.forEach(<span class="hljs-function"><span class="hljs-params">REGEX</span> =&gt;</span> {
        statements.forEach(<span class="hljs-function"><span class="hljs-params">statement</span> =&gt;</span> {
            tokens.push( <span class="hljs-comment">/* ... */</span> );
        });
    });

    <span class="hljs-keyword">return</span> tokens;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parse</span>(<span class="hljs-params">tokens</span>) </span>{
    <span class="hljs-keyword">const</span> syntaxTree = [];
    tokens.forEach(<span class="hljs-function"><span class="hljs-params">token</span> =&gt;</span> {
        syntaxTree.push( <span class="hljs-comment">/* ... */</span> );
    });

    <span class="hljs-keyword">return</span> syntaxTree;
}
</div></code></pre>
<hr>
<a for="toc-anchor" id="remove-duplicate-code"></a><h2 id="remove-duplicate-code-51">Remove duplicate code</h2>
<p>Do your absolute best to avoid duplicate code. Duplicate code is bad because it
means that there's more than one place to alter something if you need to change
some logic.</p>
<p>Imagine if you run a restaurant and you keep track of your inventory: all your
tomatoes, onions, garlic, spices, etc. If you have multiple lists that
you keep this on, then all have to be updated when you serve a dish with
tomatoes in them. If you only have one list, there's only one place to update!</p>
<p>Oftentimes you have duplicate code because you have two or more slightly
different things, that share a lot in common, but their differences force you
to have two or more separate functions that do much of the same things. Removing
duplicate code means creating an abstraction that can handle this set of
different things with just one function/module/class.</p>
<p>Getting the abstraction right is critical, that's why you should follow the
SOLID principles laid out in the <u>Classes</u> section. Bad abstractions can be
worse than duplicate code, so be careful! Having said this, if you can make
a good abstraction, do it! Don't repeat yourself, otherwise you'll find yourself
updating multiple places anytime you want to change one thing.</p>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showDeveloperList</span>(<span class="hljs-params">developers</span>) </span>{
    developers.forEach(<span class="hljs-function"><span class="hljs-params">developer</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> expectedSalary = developer.calculateExpectedSalary();
        <span class="hljs-keyword">const</span> experience = developer.getExperience();
        <span class="hljs-keyword">const</span> githubLink = developer.getGithubLink();
        <span class="hljs-keyword">const</span> data = {
            expectedSalary,
            experience,
            githubLink
        };

        render(data);
    });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showManagerList</span>(<span class="hljs-params">managers</span>) </span>{
    managers.forEach(<span class="hljs-function"><span class="hljs-params">manager</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> expectedSalary = manager.calculateExpectedSalary();
        <span class="hljs-keyword">const</span> experience = manager.getExperience();
        <span class="hljs-keyword">const</span> portfolio = manager.getMBAProjects();
        <span class="hljs-keyword">const</span> data = {
            expectedSalary,
            experience,
            portfolio
        };

        render(data);
    });
}
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showEmployeeList</span>(<span class="hljs-params">employees</span>) </span>{
    employees.forEach(<span class="hljs-function"><span class="hljs-params">employee</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> expectedSalary = employee.calculateExpectedSalary();
        <span class="hljs-keyword">const</span> experience = employee.getExperience();

        <span class="hljs-keyword">const</span> data = {
            expectedSalary,
            experience
        };

        <span class="hljs-keyword">switch</span> (employee.type) {
            <span class="hljs-keyword">case</span> <span class="hljs-string">"manager"</span>:
                data.portfolio = employee.getMBAProjects();
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">"developer"</span>:
                data.githubLink = employee.getGithubLink();
                <span class="hljs-keyword">break</span>;
        }

        render(data);
    });
}
</div></code></pre>
<hr>
<a for="toc-anchor" id="set-default-objects-with-object.assign"></a><h2 id="set-default-objects-with-objectassign-51">Set default objects with Object.assign</h2>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-keyword">const</span> menuConfig = {
    <span class="hljs-attr">title</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">body</span>: <span class="hljs-string">"Bar"</span>,
    <span class="hljs-attr">buttonText</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">cancellable</span>: <span class="hljs-literal">true</span>
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createMenu</span>(<span class="hljs-params">config</span>) </span>{
    config.title = config.title || <span class="hljs-string">"Foo"</span>;
    config.body = config.body || <span class="hljs-string">"Bar"</span>;
    config.buttonText = config.buttonText || <span class="hljs-string">"Baz"</span>;
    config.cancellable =
        config.cancellable !== <span class="hljs-literal">undefined</span> ? config.cancellable : <span class="hljs-literal">true</span>;
}

createMenu(menuConfig);
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-keyword">const</span> menuConfig = {
    <span class="hljs-attr">title</span>: <span class="hljs-string">"Order"</span>,
    <span class="hljs-comment">// User did not include 'body' key</span>
    buttonText: <span class="hljs-string">"Send"</span>,
    <span class="hljs-attr">cancellable</span>: <span class="hljs-literal">true</span>
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createMenu</span>(<span class="hljs-params">config</span>) </span>{
    <span class="hljs-keyword">let</span> finalConfig = <span class="hljs-built_in">Object</span>.assign({
            <span class="hljs-attr">title</span>: <span class="hljs-string">"Foo"</span>,
            <span class="hljs-attr">body</span>: <span class="hljs-string">"Bar"</span>,
            <span class="hljs-attr">buttonText</span>: <span class="hljs-string">"Baz"</span>,
            <span class="hljs-attr">cancellable</span>: <span class="hljs-literal">true</span>
        },
        config
    );
    <span class="hljs-keyword">return</span> finalConfig
    <span class="hljs-comment">// config now equals: {title: "Order", body: "Bar", buttonText: "Send", cancellable: true}</span>
    <span class="hljs-comment">// ...</span>
}

createMenu(menuConfig);
</div></code></pre>
<hr>
<a for="toc-anchor" id="don't-use-flags-as-function-parameters"></a><h2 id="dont-use-flags-as-function-parameters-51">Don't use flags as function parameters</h2>
<p>Flags tell your user that this function does more than one thing. Functions should do one thing. Split out your functions if they are following different code paths based on a boolean.</p>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createFile</span>(<span class="hljs-params">name, temp</span>) </span>{
    <span class="hljs-keyword">if</span> (temp) {
        fs.create( <span class="hljs-string">`./temp/<span class="hljs-subst">${name}</span>`</span> );
    } <span class="hljs-keyword">else</span> {
        fs.create(name);
    }
}
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createFile</span>(<span class="hljs-params">name</span>) </span>{
    fs.create(name);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createTempFile</span>(<span class="hljs-params">name</span>) </span>{
    createFile( <span class="hljs-string">`./temp/<span class="hljs-subst">${name}</span>`</span> );
}
</div></code></pre>
<hr>
<a for="toc-anchor" id="avoid-side-effects-(part-1)"></a><h2 id="avoid-side-effects-part-1-51">Avoid Side Effects (part 1)</h2>
<p>A function produces a side effect if it does anything other than take a value in
and return another value or values. A side effect could be writing to a file,
modifying some global variable, or accidentally wiring all your money to a
stranger.</p>
<p>Now, you do need to have side effects in a program on occasion. Like the previous
example, you might need to write to a file. What you want to do is to
centralize where you are doing this. Don't have several functions and classes
that write to a particular file. Have one service that does it. One and only one.</p>
<p>The main point is to avoid common pitfalls like sharing state between objects
without any structure, using mutable data types that can be written to by anything,
and not centralizing where your side effects occur. If you can do this, you will
be happier than the vast majority of other programmers.</p>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-comment">// Global variable referenced by following function.</span>
<span class="hljs-comment">// If we had another function that used this name, now it'd be an array and it could break it.</span>
<span class="hljs-keyword">let</span> name = <span class="hljs-string">"Ryan McDermott"</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">splitIntoFirstAndLastName</span>(<span class="hljs-params"></span>) </span>{
    name = name.split(<span class="hljs-string">" "</span>);
}

splitIntoFirstAndLastName();

<span class="hljs-built_in">console</span>.log(name); <span class="hljs-comment">// ['Ryan', 'McDermott'];</span>
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">splitIntoFirstAndLastName</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">return</span> name.split(<span class="hljs-string">" "</span>);
}

<span class="hljs-keyword">const</span> name = <span class="hljs-string">"Ryan McDermott"</span>;
<span class="hljs-keyword">const</span> newName = splitIntoFirstAndLastName(name);

<span class="hljs-built_in">console</span>.log(name); <span class="hljs-comment">// 'Ryan McDermott';</span>
<span class="hljs-built_in">console</span>.log(newName); <span class="hljs-comment">// ['Ryan', 'McDermott'];</span>
</div></code></pre>
<hr>
<a for="toc-anchor" id="avoid-side-effects-(part-2)"></a><h2 id="avoid-side-effects-part-2-51">Avoid Side Effects (part 2)</h2>
<p>In JavaScript, some values are unchangeable (immutable) and some are changeable
(mutable). Objects and arrays are two kinds of mutable values so it's important
to handle them carefully when they're passed as parameters to a function. A
JavaScript function can change an object's properties or alter the contents of
an array which could easily cause bugs elsewhere.</p>
<p>Suppose there's a function that accepts an array parameter representing a
shopping cart. If the function makes a change in that shopping cart array -
by adding an item to purchase, for example - then any other function that
uses that same <code>cart</code> array will be affected by this addition. That may be
great, however it could also be bad. Let's imagine a bad situation:</p>
<p>The user clicks the &quot;Purchase&quot; button which calls a <code>purchase</code> function that
spawns a network request and sends the <code>cart</code> array to the server. Because
of a bad network connection, the <code>purchase</code> function has to keep retrying the
request. Now, what if in the meantime the user accidentally clicks an &quot;Add to Cart&quot;
button on an item they don't actually want before the network request begins?
If that happens and the network request begins, then that purchase function
will send the accidentally added item because the <code>cart</code> array was modified.</p>
<p>A great solution would be for the <code>addItemToCart</code> function to always clone the
<code>cart</code> , edit it, and return the clone. This would ensure that functions that are still
using the old shopping cart wouldn't be affected by the changes.</p>
<p>Two caveats to mention to this approach:</p>
<ol>
<li>There might be cases where you actually want to modify the input object,</li>
</ol>
<p>but when you adopt this programming practice you will find that those cases
are pretty rare. Most things can be refactored to have no side effects!</p>
<ol start="2">
<li>Cloning big objects can be very expensive in terms of performance. Luckily,</li>
</ol>
<p>this isn't a big issue in practice because there are
<a href="https://facebook.github.io/immutable-js/">great libraries</a> that allow
this kind of programming approach to be fast and not as memory intensive as
it would be for you to manually clone objects and arrays.</p>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-keyword">const</span> addItemToCart = <span class="hljs-function">(<span class="hljs-params">cart, item</span>) =&gt;</span> {
    cart.push({
        item,
        <span class="hljs-attr">date</span>: <span class="hljs-built_in">Date</span>.now()
    });
};
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-keyword">const</span> addItemToCart = <span class="hljs-function">(<span class="hljs-params">cart, item</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> [...cart, {
        item,
        <span class="hljs-attr">date</span>: <span class="hljs-built_in">Date</span>.now()
    }];
};
</div></code></pre>
<hr>
<a for="toc-anchor" id="don't-write-to-global-functions"></a><h2 id="dont-write-to-global-functions-51">Don't write to global functions</h2>
<p>Polluting globals is a bad practice in JavaScript because you could clash with another
library and the user of your API would be none-the-wiser until they get an
exception in production. Let's think about an example: what if you wanted to
extend JavaScript's native Array method to have a <code>diff</code> method that could
show the difference between two arrays? You could write your new function
to the <code>Array.prototype</code> , but it could clash with another library that tried
to do the same thing. What if that other library was just using <code>diff</code> to find
the difference between the first and last elements of an array? This is why it
would be much better to just use ES2015/ES6 classes and simply extend the <code>Array</code> global.</p>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-built_in">Array</span>.prototype.diff = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">diff</span>(<span class="hljs-params">comparisonArray</span>) </span>{
    <span class="hljs-keyword">const</span> hash = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(comparisonArray);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.filter(<span class="hljs-function"><span class="hljs-params">elem</span> =&gt;</span> !hash.has(elem));
};
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuperArray</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Array</span> </span>{
    diff(comparisonArray) {
        <span class="hljs-keyword">const</span> hash = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(comparisonArray);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.filter(<span class="hljs-function"><span class="hljs-params">elem</span> =&gt;</span> !hash.has(elem));
    }
}
</div></code></pre>
<hr>
<a for="toc-anchor" id="favor-functional-programming-over-imperative-programming"></a><h2 id="favor-functional-programming-over-imperative-programming-51">Favor functional programming over imperative programming</h2>
<blockquote>
<p>Modern programming languages fall into two categories: imperative (also called procedural) and declarative (also called functional).
Object-oriented programming (OOP), procedural programming, and parallel processing are examples of the imperative programming paradigm.
Functional programming, logic programming, and database processing are examples of the declarative programming paradigm.
Why JavaScript is a &quot;multi-paradigm&quot; language
JavaScript supports both object-oriented programming with prototypal inheritance as well as functional programming.
Java was traditionally an example of pure object-oriented programming, though the 2018 release added functional programming in the form of something that we will discuss called lambdas.
SQL is an example of pure declarative programming, though there are extensions available from vendors that add procedural elements.</p>
</blockquote>
<hr>
<a for="toc-anchor" id="characteristics-of-declarative-(functional)-programming"></a><h2 id="characteristics-of-declarative-functional-programming-36">Characteristics of declarative (functional) programming</h2>
<ul>
<li>You declare what you want to happen, not how it's done.</li>
<li>There are no loops or conditional statements (for a set-based language, like SQL, where you think of data in columns instead of in rows).</li>
<li>There are plenty of filters and operations on the data as a whole, but the data is often considered immutable values (not changeable).</li>
</ul>
<hr>
<a for="toc-anchor" id="characteristics-of-imperative-(procedural-%2F-oop)-programming"></a><h2 id="characteristics-of-imperative-procedural--oop-programming-36">Characteristics of imperative (procedural / OOP) programming</h2>
<ul>
<li>You specify exactly how to do something, not just the desired outcome.</li>
<li>Variables, pointers, and stored procedures are commonplace, and data is often considered mutable variables (changeable)</li>
<li>Inheritance is commonplace and typically used as an example of reusable, clean code that helps future developers</li>
</ul>
<hr>
<a for="toc-anchor" id="prototypes-and-prototypal-inheritance"></a><h2 id="prototypes-and-prototypal-inheritance-36">Prototypes and prototypal inheritance</h2>
<ul>
<li>Prototypal Inheritance — yes, that's how it's spelled — means that vanilla Javascript has objects without classes. This type of inheritance is sometimes called prototype delegation, Behavior Delegation Pattern, or OLOO (Objects Linking to Other Objects).</li>
<li>In JavaScript, it creates a link when we create the object. For objects and class inheritance, it does not copy but only links properties and behavior.</li>
<li>Diagramatically, inheritance is flowing up the chain of inheritance because it's a behavior delegation link, also known as prototype chain.</li>
</ul>
<hr>
<a for="toc-anchor" id="how-javascript-differs-from-other-programming-languages"></a><h2 id="how-javascript-differs-from-other-programming-languages-36">How JavaScript differs from other programming languages</h2>
<ul>
<li>Other languages have &quot;classical inheritance&quot; where the software creates a copy of the behavior from parent class into the child when we extend that class. After that the parent and child classes become separate entities.</li>
<li>Behaviors and properties are copied when we create an object or instance of a class using a constructor. At that point both are separate entities.</li>
<li>That's because they are not linked — it's just a copy from one to the other.</li>
<li>Compare that to Javascript, where the child's behavior is just a link up to the parent class's behavior.</li>
</ul>
<hr>
<p>Functional languages can be cleaner and easier to test.
Favor this style of programming when you can.</p>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-keyword">const</span> programmerOutput = [{
        <span class="hljs-attr">name</span>: <span class="hljs-string">"Uncle Bobby"</span>,
        <span class="hljs-attr">linesOfCode</span>: <span class="hljs-number">500</span>
    },
    {
        <span class="hljs-attr">name</span>: <span class="hljs-string">"Suzie Q"</span>,
        <span class="hljs-attr">linesOfCode</span>: <span class="hljs-number">1500</span>
    },
    {
        <span class="hljs-attr">name</span>: <span class="hljs-string">"Jimmy Gosling"</span>,
        <span class="hljs-attr">linesOfCode</span>: <span class="hljs-number">150</span>
    },
    {
        <span class="hljs-attr">name</span>: <span class="hljs-string">"Gracie Hopper"</span>,
        <span class="hljs-attr">linesOfCode</span>: <span class="hljs-number">1000</span>
    }
];

<span class="hljs-keyword">let</span> totalOutput = <span class="hljs-number">0</span>;

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; programmerOutput.length; i++) {
    totalOutput += programmerOutput[i].linesOfCode;
}
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-keyword">const</span> programmerOutput = [{
        <span class="hljs-attr">name</span>: <span class="hljs-string">"Uncle Bobby"</span>,
        <span class="hljs-attr">linesOfCode</span>: <span class="hljs-number">500</span>
    },
    {
        <span class="hljs-attr">name</span>: <span class="hljs-string">"Suzie Q"</span>,
        <span class="hljs-attr">linesOfCode</span>: <span class="hljs-number">1500</span>
    },
    {
        <span class="hljs-attr">name</span>: <span class="hljs-string">"Jimmy Gosling"</span>,
        <span class="hljs-attr">linesOfCode</span>: <span class="hljs-number">150</span>
    },
    {
        <span class="hljs-attr">name</span>: <span class="hljs-string">"Gracie Hopper"</span>,
        <span class="hljs-attr">linesOfCode</span>: <span class="hljs-number">1000</span>
    }
];

<span class="hljs-keyword">const</span> totalOutput = programmerOutput.reduce(
    <span class="hljs-function">(<span class="hljs-params">totalLines, output</span>) =&gt;</span> totalLines + output.linesOfCode,
    <span class="hljs-number">0</span>
);
</div></code></pre>
<hr>
<a for="toc-anchor" id="encapsulate-conditionals"></a><h2 id="encapsulate-conditionals-51">Encapsulate conditionals</h2>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-keyword">if</span> (fsm.state === <span class="hljs-string">"fetching"</span> &amp;&amp; isEmpty(listNode)) {
    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shouldShowSpinner</span>(<span class="hljs-params">fsm, listNode</span>) </span>{
    <span class="hljs-keyword">return</span> fsm.state === <span class="hljs-string">"fetching"</span> &amp;&amp; isEmpty(listNode);
}

<span class="hljs-keyword">if</span> (shouldShowSpinner(fsmInstance, listNodeInstance)) {
    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<hr>
<a for="toc-anchor" id="avoid-negative-conditionals"></a><h2 id="avoid-negative-conditionals-51">Avoid negative conditionals</h2>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isDOMNodeNotPresent</span>(<span class="hljs-params">node</span>) </span>{
    <span class="hljs-comment">// ...</span>
}

<span class="hljs-keyword">if</span> (!isDOMNodeNotPresent(node)) {
    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isDOMNodePresent</span>(<span class="hljs-params">node</span>) </span>{
    <span class="hljs-comment">// ...</span>
}

<span class="hljs-keyword">if</span> (isDOMNodePresent(node)) {
    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<hr>
<a for="toc-anchor" id="avoid-conditionals"></a><h2 id="avoid-conditionals-51">Avoid conditionals</h2>
<p>This seems like an impossible task. Upon first hearing this, most people say,
&quot;how am I supposed to do anything without an <code>if</code> statement?&quot; The answer is that
you can use polymorphism to achieve the same task in many cases. The second
question is usually, &quot;well that's great but why would I want to do that?&quot; The
answer is a previous clean code concept we learned: a function should only do
one thing. When you have classes and functions that have <code>if</code> statements, you
are telling your user that your function does more than one thing. Remember,
just do one thing.</p>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Airplane</span> </span>{
    <span class="hljs-comment">// ...</span>
    getCruisingAltitude() {
        <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>.type) {
            <span class="hljs-keyword">case</span> <span class="hljs-string">"777"</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getMaxAltitude() - <span class="hljs-keyword">this</span>.getPassengerCount();
            <span class="hljs-keyword">case</span> <span class="hljs-string">"Air Force One"</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getMaxAltitude();
            <span class="hljs-keyword">case</span> <span class="hljs-string">"Cessna"</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getMaxAltitude() - <span class="hljs-keyword">this</span>.getFuelExpenditure();
        }
    }
}
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Airplane</span> </span>{
    <span class="hljs-comment">// ...</span>
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Boeing777</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Airplane</span> </span>{
    <span class="hljs-comment">// ...</span>
    getCruisingAltitude() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getMaxAltitude() - <span class="hljs-keyword">this</span>.getPassengerCount();
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AirForceOne</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Airplane</span> </span>{
    <span class="hljs-comment">// ...</span>
    getCruisingAltitude() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getMaxAltitude();
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cessna</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Airplane</span> </span>{
    <span class="hljs-comment">// ...</span>
    getCruisingAltitude() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getMaxAltitude() - <span class="hljs-keyword">this</span>.getFuelExpenditure();
    }
}
</div></code></pre>
<hr>
<a for="toc-anchor" id="avoid-type-checking-(part-1)"></a><h2 id="avoid-type-checking-part-1-51">Avoid type-checking (part 1)</h2>
<p>JavaScript is untyped, which means your functions can take any type of argument.
Sometimes you are bitten by this freedom and it becomes tempting to do
type-checking in your functions. There are many ways to avoid having to do this.
The first thing to consider is consistent APIs.</p>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">travelToTexas</span>(<span class="hljs-params">vehicle</span>) </span>{
    <span class="hljs-keyword">if</span> (vehicle <span class="hljs-keyword">instanceof</span> Bicycle) {
        vehicle.pedal(<span class="hljs-keyword">this</span>.currentLocation, <span class="hljs-keyword">new</span> Location(<span class="hljs-string">"texas"</span>));
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vehicle <span class="hljs-keyword">instanceof</span> Car) {
        vehicle.drive(<span class="hljs-keyword">this</span>.currentLocation, <span class="hljs-keyword">new</span> Location(<span class="hljs-string">"texas"</span>));
    }
}
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">travelToTexas</span>(<span class="hljs-params">vehicle</span>) </span>{
    vehicle.move(<span class="hljs-keyword">this</span>.currentLocation, <span class="hljs-keyword">new</span> Location(<span class="hljs-string">"texas"</span>));
}
</div></code></pre>
<hr>
<a for="toc-anchor" id="avoid-type-checking-(part-2)"></a><h2 id="avoid-type-checking-part-2-51">Avoid type-checking (part 2)</h2>
<p>If you are working with basic primitive values like strings and integers,
and you can't use polymorphism but you still feel the need to type-check,
you should consider using TypeScript. It is an excellent alternative to normal
JavaScript, as it provides you with static typing on top of standard JavaScript
syntax. The problem with manually type-checking normal JavaScript is that
doing it well requires so much extra verbiage that the faux &quot;type-safety&quot; you get
doesn't make up for the lost readability. Keep your JavaScript clean, write
good tests, and have good code reviews. Otherwise, do all of that but with
TypeScript (which, like I said, is a great alternative!).</p>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">combine</span>(<span class="hljs-params">val1, val2</span>) </span>{
    <span class="hljs-keyword">if</span> (
        (<span class="hljs-keyword">typeof</span> val1 === <span class="hljs-string">"number"</span> &amp;&amp; <span class="hljs-keyword">typeof</span> val2 === <span class="hljs-string">"number"</span>) ||
        (<span class="hljs-keyword">typeof</span> val1 === <span class="hljs-string">"string"</span> &amp;&amp; <span class="hljs-keyword">typeof</span> val2 === <span class="hljs-string">"string"</span>)
    ) {
        <span class="hljs-keyword">return</span> val1 + val2;
    }

    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Must be of type String or Number"</span>);
}
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">combine</span>(<span class="hljs-params">val1, val2</span>) </span>{
    <span class="hljs-keyword">return</span> val1 + val2;
}
</div></code></pre>
<hr>
<a for="toc-anchor" id="don't-over-optimize"></a><h2 id="dont-over-optimize-51">Don't over-optimize</h2>
<p>Modern browsers do a lot of optimization under-the-hood at runtime. A lot of
times, if you are optimizing then you are just wasting your time. <a href="https://github.com/petkaantonov/bluebird/wiki/Optimization-killers">There are good
resources</a>
for seeing where optimization is lacking. Target those in the meantime, until
they are fixed if they can be.</p>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-comment">// On old browsers, each iteration with uncached `list.length` would be costly</span>
<span class="hljs-comment">// because of `list.length` recomputation. In modern browsers, this is optimized.</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = list.length; i &lt; len; i++) {
    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; list.length; i++) {
    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<hr>
<a for="toc-anchor" id="remove-dead-code"></a><h2 id="remove-dead-code-51">Remove dead code</h2>
<p>Dead code is just as bad as duplicate code. There's no reason to keep it in
your codebase. If it's not being called, get rid of it! It will still be safe
in your version history if you still need it.</p>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">oldRequestModule</span>(<span class="hljs-params">url</span>) </span>{
    <span class="hljs-comment">// ...</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">newRequestModule</span>(<span class="hljs-params">url</span>) </span>{
    <span class="hljs-comment">// ...</span>
}

<span class="hljs-keyword">const</span> req = newRequestModule;
inventoryTracker(<span class="hljs-string">"apples"</span>, req, <span class="hljs-string">"www.inventory-awesome.io"</span>);
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">newRequestModule</span>(<span class="hljs-params">url</span>) </span>{
    <span class="hljs-comment">// ...</span>
}

<span class="hljs-keyword">const</span> req = newRequestModule;
inventoryTracker(<span class="hljs-string">"apples"</span>, req, <span class="hljs-string">"www.inventory-awesome.io"</span>);
</div></code></pre>
<a for="toc-anchor" id="%3Eobjects-and-data-structures%3E"></a><h2 id="blockquoteobjects-and-data-structuresblockquote-8">&gt;Objects and Data Structures&gt;</h2>
<hr>
<a for="toc-anchor" id="use-getters-and-setters"></a><h2 id="use-getters-and-setters-51">Use getters and setters</h2>
<p>Using getters and setters to access data on objects could be better than simply
looking for a property on an object. &quot;Why?&quot; you might ask. Well, here's an
unorganized list of reasons why:</p>
<ul>
<li>
<p>When you want to do more beyond getting an object property, you don't have</p>
<p>to look up and change every accessor in your codebase.</p>
</li>
<li>
<p>Makes adding validation simple when doing a <code>set</code> .</p>
</li>
<li>
<p>Encapsulates the internal representation.</p>
</li>
<li>
<p>Easy to add logging and error handling when getting and setting.</p>
</li>
<li>
<p>You can lazy load your object's properties, let's say getting it from a</p>
<p>server.</p>
</li>
</ul>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeBankAccount</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// ...</span>

    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">balance</span>: <span class="hljs-number">0</span>
        <span class="hljs-comment">// ...</span>
    };
}

<span class="hljs-keyword">const</span> account = makeBankAccount();
account.balance = <span class="hljs-number">100</span>;
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeBankAccount</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// this one is private</span>
    <span class="hljs-keyword">let</span> balance = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// a "getter", made public via the returned object below</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getBalance</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> balance;
    }

    <span class="hljs-comment">// a "setter", made public via the returned object below</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setBalance</span>(<span class="hljs-params">amount</span>) </span>{
        <span class="hljs-comment">// ... validate before updating the balance</span>
        balance = amount;
    }

    <span class="hljs-keyword">return</span> {
        <span class="hljs-comment">// ...</span>
        getBalance,
        setBalance
    };
}

<span class="hljs-keyword">const</span> account = makeBankAccount();
account.setBalance(<span class="hljs-number">100</span>);
</div></code></pre>
<hr>
<a for="toc-anchor" id="make-objects-have-private-members"></a><h2 id="make-objects-have-private-members-51">Make objects have private members</h2>
<p>This can be accomplished through closures (for ES5 and below).</p>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-keyword">const</span> Employee = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">this</span>.name = name;
};

Employee.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;
};

<span class="hljs-keyword">const</span> employee = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">"John Doe"</span>);
<span class="hljs-built_in">console</span>.log( <span class="hljs-string">`Employee name: <span class="hljs-subst">${employee.getName()}</span>`</span> ); <span class="hljs-comment">// Employee name: John Doe</span>
<span class="hljs-keyword">delete</span> employee.name;
<span class="hljs-built_in">console</span>.log( <span class="hljs-string">`Employee name: <span class="hljs-subst">${employee.getName()}</span>`</span> ); <span class="hljs-comment">// Employee name: undefined</span>
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeEmployee</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">return</span> {
        getName() {
            <span class="hljs-keyword">return</span> name;
        }
    };
}

<span class="hljs-keyword">const</span> employee = makeEmployee(<span class="hljs-string">"John Doe"</span>);
<span class="hljs-built_in">console</span>.log( <span class="hljs-string">`Employee name: <span class="hljs-subst">${employee.getName()}</span>`</span> ); <span class="hljs-comment">// Employee name: John Doe</span>
<span class="hljs-keyword">delete</span> employee.name;
<span class="hljs-built_in">console</span>.log( <span class="hljs-string">`Employee name: <span class="hljs-subst">${employee.getName()}</span>`</span> ); <span class="hljs-comment">// Employee name: John Doe</span>
</div></code></pre>
<a for="toc-anchor" id="%3Eclasses%3E"></a><h2 id="blockquoteclassesblockquote-8">&gt;Classes&gt;</h2>
<hr>
<a for="toc-anchor" id="prefer-es2015%2Fes6-classes-over-es5-plain-functions"></a><h2 id="prefer-es2015es6-classes-over-es5-plain-functions-51">Prefer ES2015/ES6 classes over ES5 plain functions</h2>
<p>It's very difficult to get readable class inheritance, construction, and method
definitions for classical ES5 classes. If you need inheritance (and be aware
that you might not), then prefer ES2015/ES6 classes. However, prefer small functions over
classes until you find yourself needing larger and more complex objects.</p>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-keyword">const</span> Animal = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">age</span>) </span>{
    <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Animal)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Instantiate Animal with `new` "</span>);
    }

    <span class="hljs-keyword">this</span>.age = age;
};

Animal.prototype.move = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">move</span>(<span class="hljs-params"></span>) </span>{};

<span class="hljs-keyword">const</span> Mammal = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">age, furColor</span>) </span>{
    <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Mammal)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Instantiate Mammal with `new` "</span>);
    }

    Animal.call(<span class="hljs-keyword">this</span>, age);
    <span class="hljs-keyword">this</span>.furColor = furColor;
};

Mammal.prototype = <span class="hljs-built_in">Object</span>.create(Animal.prototype);
Mammal.prototype.constructor = Mammal;
Mammal.prototype.liveBirth = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">liveBirth</span>(<span class="hljs-params"></span>) </span>{};

<span class="hljs-keyword">const</span> Human = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">age, furColor, languageSpoken</span>) </span>{
    <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Human)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Instantiate Human with `new` "</span>);
    }

    Mammal.call(<span class="hljs-keyword">this</span>, age, furColor);
    <span class="hljs-keyword">this</span>.languageSpoken = languageSpoken;
};

Human.prototype = <span class="hljs-built_in">Object</span>.create(Mammal.prototype);
Human.prototype.constructor = Human;
Human.prototype.speak = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">speak</span>(<span class="hljs-params"></span>) </span>{};
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{
    <span class="hljs-keyword">constructor</span>(age) {
        <span class="hljs-keyword">this</span>.age = age;
    }

    move() {
        <span class="hljs-comment">/* ... */</span>
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mammal</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>{
    <span class="hljs-keyword">constructor</span>(age, furColor) {
        <span class="hljs-keyword">super</span>(age);
        <span class="hljs-keyword">this</span>.furColor = furColor;
    }

    liveBirth() {
        <span class="hljs-comment">/* ... */</span>
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Human</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mammal</span> </span>{
    <span class="hljs-keyword">constructor</span>(age, furColor, languageSpoken) {
        <span class="hljs-keyword">super</span>(age, furColor);
        <span class="hljs-keyword">this</span>.languageSpoken = languageSpoken;
    }

    speak() {
        <span class="hljs-comment">/* ... */</span>
    }
}
</div></code></pre>
<hr>
<a for="toc-anchor" id="use-method-chaining"></a><h2 id="use-method-chaining-51">Use method chaining</h2>
<p>This pattern is very useful in JavaScript and you see it in many libraries such
as jQuery and Lodash. It allows your code to be expressive, and less verbose.
For that reason, I say, use method chaining and take a look at how clean your code
will be. In your class functions, simply return <code>this</code> at the end of every function,
and you can chain further class methods onto it.</p>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>{
    <span class="hljs-keyword">constructor</span>(make, model, color) {
        <span class="hljs-keyword">this</span>.make = make;
        <span class="hljs-keyword">this</span>.model = model;
        <span class="hljs-keyword">this</span>.color = color;
    }

    setMake(make) {
        <span class="hljs-keyword">this</span>.make = make;
    }

    setModel(model) {
        <span class="hljs-keyword">this</span>.model = model;
    }

    setColor(color) {
        <span class="hljs-keyword">this</span>.color = color;
    }

    save() {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.make, <span class="hljs-keyword">this</span>.model, <span class="hljs-keyword">this</span>.color);
    }
}

<span class="hljs-keyword">const</span> car = <span class="hljs-keyword">new</span> Car(<span class="hljs-string">"Ford"</span>, <span class="hljs-string">"F-150"</span>, <span class="hljs-string">"red"</span>);
car.setColor(<span class="hljs-string">"pink"</span>);
car.save();
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>{
    <span class="hljs-keyword">constructor</span>(make, model, color) {
        <span class="hljs-keyword">this</span>.make = make;
        <span class="hljs-keyword">this</span>.model = model;
        <span class="hljs-keyword">this</span>.color = color;
    }

    setMake(make) {
        <span class="hljs-keyword">this</span>.make = make;
        <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> Returning this for chaining</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }

    setModel(model) {
        <span class="hljs-keyword">this</span>.model = model;
        <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> Returning this for chaining</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }

    setColor(color) {
        <span class="hljs-keyword">this</span>.color = color;
        <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> Returning this for chaining</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }

    save() {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.make, <span class="hljs-keyword">this</span>.model, <span class="hljs-keyword">this</span>.color);
        <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> Returning this for chaining</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }
}

<span class="hljs-keyword">const</span> car = <span class="hljs-keyword">new</span> Car(<span class="hljs-string">"Ford"</span>, <span class="hljs-string">"F-150"</span>, <span class="hljs-string">"red"</span>).setColor(<span class="hljs-string">"pink"</span>).save();
</div></code></pre>
<hr>
<a for="toc-anchor" id="prefer-composition-over-inheritance"></a><h2 id="prefer-composition-over-inheritance-51">Prefer composition over inheritance</h2>
<p>As stated famously in <a href="https://en.wikipedia.org/wiki/Design_Patterns"><u>Design Patterns</u></a> by the Gang of Four,
you should prefer composition over inheritance where you can. There are lots of
good reasons to use inheritance and lots of good reasons to use composition.
The main point for this maxim is that if your mind instinctively goes for
inheritance, try to think if composition could model your problem better. In some
cases it can.</p>
<p>You might be wondering then, &quot;when should I use inheritance?&quot; It
depends on your problem at hand, but this is a decent list of when inheritance
makes more sense than composition:</p>
<ol>
<li>Your inheritance represents an &quot;is-a&quot; relationship and not a &quot;has-a&quot;</li>
</ol>
<p>relationship (Human-&gt;Animal vs. User-&gt;UserDetails).</p>
<ol start="2">
<li>You can reuse code from the base classes (Humans can move like all animals).</li>
<li>You want to make global changes to derived classes by changing a base class.</li>
</ol>
<p>(Change the caloric expenditure of all animals when they move).</p>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>{
    <span class="hljs-keyword">constructor</span>(name, email) {
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.email = email;
    }

    <span class="hljs-comment">// ...</span>
}

<span class="hljs-comment">// Bad because Employees "have" tax data. EmployeeTaxData is not a type of Employee</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmployeeTaxData</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Employee</span> </span>{
    <span class="hljs-keyword">constructor</span>(ssn, salary) {
        <span class="hljs-keyword">super</span>();
        <span class="hljs-keyword">this</span>.ssn = ssn;
        <span class="hljs-keyword">this</span>.salary = salary;
    }

    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmployeeTaxData</span> </span>{
    <span class="hljs-keyword">constructor</span>(ssn, salary) {
        <span class="hljs-keyword">this</span>.ssn = ssn;
        <span class="hljs-keyword">this</span>.salary = salary;
    }

    <span class="hljs-comment">// ...</span>
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>{
    <span class="hljs-keyword">constructor</span>(name, email) {
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.email = email;
    }

    setTaxData(ssn, salary) {
        <span class="hljs-keyword">this</span>.taxData = <span class="hljs-keyword">new</span> EmployeeTaxData(ssn, salary);
    }
    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<a for="toc-anchor" id="%3Esolid%3E"></a><h2 id="blockquotesolidblockquote-8">&gt;SOLID&gt;</h2>
<hr>
<a for="toc-anchor" id="single-responsibility-principle-(srp)"></a><h2 id="single-responsibility-principle-srp-51">Single Responsibility Principle (SRP)</h2>
<p>As stated in Clean Code, &quot;There should never be more than one reason for a class
to change&quot;. It's tempting to jam-pack a class with a lot of functionality, like
when you can only take one suitcase on your flight. The issue with this is
that your class won't be conceptually cohesive and it will give it many reasons
to change. Minimizing the amount of times you need to change a class is important.
It's important because if too much functionality is in one class and you modify
a piece of it, it can be difficult to understand how that will affect other
dependent modules in your codebase.</p>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserSettings</span> </span>{
    <span class="hljs-keyword">constructor</span>(user) {
        <span class="hljs-keyword">this</span>.user = user;
    }

    changeSettings(settings) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.verifyCredentials()) {
            <span class="hljs-comment">// ...</span>
        }
    }

    verifyCredentials() {
        <span class="hljs-comment">// ...</span>
    }
}
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserAuth</span> </span>{
    <span class="hljs-keyword">constructor</span>(user) {
        <span class="hljs-keyword">this</span>.user = user;
    }

    verifyCredentials() {
        <span class="hljs-comment">// ...</span>
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserSettings</span> </span>{
    <span class="hljs-keyword">constructor</span>(user) {
        <span class="hljs-keyword">this</span>.user = user;
        <span class="hljs-keyword">this</span>.auth = <span class="hljs-keyword">new</span> UserAuth(user);
    }

    changeSettings(settings) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.auth.verifyCredentials()) {
            <span class="hljs-comment">// ...</span>
        }
    }
}
</div></code></pre>
<hr>
<a for="toc-anchor" id="open%2Fclosed-principle-(ocp)"></a><h2 id="openclosed-principle-ocp-51">Open/Closed Principle (OCP)</h2>
<p>As stated by Bertrand Meyer, &quot;software entities (classes, modules, functions,
etc.) should be open for extension, but closed for modification.&quot; What does that
mean though? This principle basically states that you should allow users to
add new functionalities without changing existing code.</p>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AjaxAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Adapter</span> </span>{
    <span class="hljs-keyword">constructor</span>() {
        <span class="hljs-keyword">super</span>();
        <span class="hljs-keyword">this</span>.name = <span class="hljs-string">"ajaxAdapter"</span>;
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NodeAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Adapter</span> </span>{
    <span class="hljs-keyword">constructor</span>() {
        <span class="hljs-keyword">super</span>();
        <span class="hljs-keyword">this</span>.name = <span class="hljs-string">"nodeAdapter"</span>;
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpRequester</span> </span>{
    <span class="hljs-keyword">constructor</span>(adapter) {
        <span class="hljs-keyword">this</span>.adapter = adapter;
    }

    fetch(url) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.adapter.name === <span class="hljs-string">"ajaxAdapter"</span>) {
            <span class="hljs-keyword">return</span> makeAjaxCall(url).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {
                <span class="hljs-comment">// transform response and return</span>
            });
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.adapter.name === <span class="hljs-string">"nodeAdapter"</span>) {
            <span class="hljs-keyword">return</span> makeHttpCall(url).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {
                <span class="hljs-comment">// transform response and return</span>
            });
        }
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeAjaxCall</span>(<span class="hljs-params">url</span>) </span>{
    <span class="hljs-comment">// request and return promise</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeHttpCall</span>(<span class="hljs-params">url</span>) </span>{
    <span class="hljs-comment">// request and return promise</span>
}
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AjaxAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Adapter</span> </span>{
    <span class="hljs-keyword">constructor</span>() {
        <span class="hljs-keyword">super</span>();
        <span class="hljs-keyword">this</span>.name = <span class="hljs-string">"ajaxAdapter"</span>;
    }

    request(url) {
        <span class="hljs-comment">// request and return promise</span>
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NodeAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Adapter</span> </span>{
    <span class="hljs-keyword">constructor</span>() {
        <span class="hljs-keyword">super</span>();
        <span class="hljs-keyword">this</span>.name = <span class="hljs-string">"nodeAdapter"</span>;
    }

    request(url) {
        <span class="hljs-comment">// request and return promise</span>
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpRequester</span> </span>{
    <span class="hljs-keyword">constructor</span>(adapter) {
        <span class="hljs-keyword">this</span>.adapter = adapter;
    }

    fetch(url) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.adapter.request(url).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {
            <span class="hljs-comment">// transform response and return</span>
        });
    }
}
</div></code></pre>
<hr>
<a for="toc-anchor" id="liskov-substitution-principle-(lsp)"></a><h2 id="liskov-substitution-principle-lsp-51">Liskov Substitution Principle (LSP)</h2>
<p>This is a scary term for a very simple concept. It's formally defined as &quot;If S
is a subtype of T, then objects of type T may be replaced with objects of type S
(i.e., objects of type S may substitute objects of type T) without altering any
of the desirable properties of that program (correctness, task performed,
etc.).&quot; That's an even scarier definition.</p>
<p>The best explanation for this is if you have a parent class and a child class,
then the base class and child class can be used interchangeably without getting
incorrect results. This might still be confusing, so let's take a look at the
classic Square-Rectangle example. Mathematically, a square is a rectangle, but
if you model it using the &quot;is-a&quot; relationship via inheritance, you quickly
get into trouble.</p>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> </span>{
    <span class="hljs-keyword">constructor</span>() {
        <span class="hljs-keyword">this</span>.width = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">this</span>.height = <span class="hljs-number">0</span>;
    }

    setColor(color) {
        <span class="hljs-comment">// ...</span>
    }

    render(area) {
        <span class="hljs-comment">// ...</span>
    }

    setWidth(width) {
        <span class="hljs-keyword">this</span>.width = width;
    }

    setHeight(height) {
        <span class="hljs-keyword">this</span>.height = height;
    }

    getArea() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.width * <span class="hljs-keyword">this</span>.height;
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Rectangle</span> </span>{
    setWidth(width) {
        <span class="hljs-keyword">this</span>.width = width;
        <span class="hljs-keyword">this</span>.height = width;
    }

    setHeight(height) {
        <span class="hljs-keyword">this</span>.width = height;
        <span class="hljs-keyword">this</span>.height = height;
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderLargeRectangles</span>(<span class="hljs-params">rectangles</span>) </span>{
    rectangles.forEach(<span class="hljs-function"><span class="hljs-params">rectangle</span> =&gt;</span> {
        rectangle.setWidth(<span class="hljs-number">4</span>);
        rectangle.setHeight(<span class="hljs-number">5</span>);
        <span class="hljs-keyword">const</span> area = rectangle.getArea(); <span class="hljs-comment">// BAD: Returns 25 for Square. Should be 20.</span>
        rectangle.render(area);
    });
}

<span class="hljs-keyword">const</span> rectangles = [<span class="hljs-keyword">new</span> Rectangle(), <span class="hljs-keyword">new</span> Rectangle(), <span class="hljs-keyword">new</span> Square()];
renderLargeRectangles(rectangles);
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span> </span>{
    setColor(color) {
        <span class="hljs-comment">// ...</span>
    }

    render(area) {
        <span class="hljs-comment">// ...</span>
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>{
    <span class="hljs-keyword">constructor</span>(width, height) {
        <span class="hljs-keyword">super</span>();
        <span class="hljs-keyword">this</span>.width = width;
        <span class="hljs-keyword">this</span>.height = height;
    }

    getArea() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.width * <span class="hljs-keyword">this</span>.height;
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>{
    <span class="hljs-keyword">constructor</span>(length) {
        <span class="hljs-keyword">super</span>();
        <span class="hljs-keyword">this</span>.length = length;
    }

    getArea() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.length * <span class="hljs-keyword">this</span>.length;
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderLargeShapes</span>(<span class="hljs-params">shapes</span>) </span>{
    shapes.forEach(<span class="hljs-function"><span class="hljs-params">shape</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> area = shape.getArea();
        shape.render(area);
    });
}

<span class="hljs-keyword">const</span> shapes = [<span class="hljs-keyword">new</span> Rectangle(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>), <span class="hljs-keyword">new</span> Rectangle(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>), <span class="hljs-keyword">new</span> Square(<span class="hljs-number">5</span>)];
renderLargeShapes(shapes);
</div></code></pre>
<hr>
<a for="toc-anchor" id="interface-segregation-principle-(isp)"></a><h2 id="interface-segregation-principle-isp-51">Interface Segregation Principle (ISP)</h2>
<p>JavaScript doesn't have interfaces so this principle doesn't apply as strictly
as others. However, it's important and relevant even with JavaScript's lack of
type system.</p>
<p>ISP states that &quot;Clients should not be forced to depend upon interfaces that
they do not use.&quot; Interfaces are implicit contracts in JavaScript because of
duck typing.</p>
<p>A good example to look at that demonstrates this principle in JavaScript is for
classes that require large settings objects. Not requiring clients to setup
huge amounts of options is beneficial, because most of the time they won't need
all of the settings. Making them optional helps prevent having a
&quot;fat interface&quot;.</p>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DOMTraverser</span> </span>{
    <span class="hljs-keyword">constructor</span>(settings) {
        <span class="hljs-keyword">this</span>.settings = settings;
        <span class="hljs-keyword">this</span>.setup();
    }

    setup() {
        <span class="hljs-keyword">this</span>.rootNode = <span class="hljs-keyword">this</span>.settings.rootNode;
        <span class="hljs-keyword">this</span>.settings.animationModule.setup();
    }

    traverse() {
        <span class="hljs-comment">// ...</span>
    }
}

<span class="hljs-keyword">const</span> $ = <span class="hljs-keyword">new</span> DOMTraverser({
    <span class="hljs-attr">rootNode</span>: <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">"body"</span>),
    animationModule() {} <span class="hljs-comment">// Most of the time, we won't need to animate when traversing.</span>
    <span class="hljs-comment">// ...</span>
});
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DOMTraverser</span> </span>{
    <span class="hljs-keyword">constructor</span>(settings) {
        <span class="hljs-keyword">this</span>.settings = settings;
        <span class="hljs-keyword">this</span>.options = settings.options;
        <span class="hljs-keyword">this</span>.setup();
    }

    setup() {
        <span class="hljs-keyword">this</span>.rootNode = <span class="hljs-keyword">this</span>.settings.rootNode;
        <span class="hljs-keyword">this</span>.setupOptions();
    }

    setupOptions() {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.animationModule) {
            <span class="hljs-comment">// ...</span>
        }
    }

    traverse() {
        <span class="hljs-comment">// ...</span>
    }
}

<span class="hljs-keyword">const</span> $ = <span class="hljs-keyword">new</span> DOMTraverser({
    <span class="hljs-attr">rootNode</span>: <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">"body"</span>),
    <span class="hljs-attr">options</span>: {
        animationModule() {}
    }
});
</div></code></pre>
<hr>
<a for="toc-anchor" id="dependency-inversion-principle-(dip)"></a><h2 id="dependency-inversion-principle-dip-51">Dependency Inversion Principle (DIP)</h2>
<p>This principle states two essential things:</p>
<ol>
<li>High-level modules should not depend on low-level modules. Both should</li>
</ol>
<p>depend on abstractions.</p>
<ol start="2">
<li>Abstractions should not depend upon details. Details should depend on</li>
</ol>
<p>abstractions.</p>
<p>This can be hard to understand at first, but if you've worked with AngularJS,
you've seen an implementation of this principle in the form of Dependency
Injection (DI). While they are not identical concepts, DIP keeps high-level
modules from knowing the details of its low-level modules and setting them up.
It can accomplish this through DI. A huge benefit of this is that it reduces
the coupling between modules. Coupling is a very bad development pattern because
it makes your code hard to refactor.</p>
<p>As stated previously, JavaScript doesn't have interfaces so the abstractions
that are depended upon are implicit contracts. That is to say, the methods
and properties that an object/class exposes to another object/class. In the
example below, the implicit contract is that any Request module for an
<code>InventoryTracker</code> will have a <code>requestItems</code> method.</p>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InventoryRequester</span> </span>{
    <span class="hljs-keyword">constructor</span>() {
        <span class="hljs-keyword">this</span>.REQ_METHODS = [<span class="hljs-string">"HTTP"</span>];
    }

    requestItem(item) {
        <span class="hljs-comment">// ...</span>
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InventoryTracker</span> </span>{
    <span class="hljs-keyword">constructor</span>(items) {
        <span class="hljs-keyword">this</span>.items = items;

        <span class="hljs-comment">// BAD: We have created a dependency on a specific request implementation.</span>
        <span class="hljs-comment">// We should just have requestItems depend on a request method: `request`</span>
        <span class="hljs-keyword">this</span>.requester = <span class="hljs-keyword">new</span> InventoryRequester();
    }

    requestItems() {
        <span class="hljs-keyword">this</span>.items.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> {
            <span class="hljs-keyword">this</span>.requester.requestItem(item);
        });
    }
}

<span class="hljs-keyword">const</span> inventoryTracker = <span class="hljs-keyword">new</span> InventoryTracker([<span class="hljs-string">"apples"</span>, <span class="hljs-string">"bananas"</span>]);
inventoryTracker.requestItems();
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InventoryTracker</span> </span>{
    <span class="hljs-keyword">constructor</span>(items, requester) {
        <span class="hljs-keyword">this</span>.items = items;
        <span class="hljs-keyword">this</span>.requester = requester;
    }

    requestItems() {
        <span class="hljs-keyword">this</span>.items.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> {
            <span class="hljs-keyword">this</span>.requester.requestItem(item);
        });
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InventoryRequesterV1</span> </span>{
    <span class="hljs-keyword">constructor</span>() {
        <span class="hljs-keyword">this</span>.REQ_METHODS = [<span class="hljs-string">"HTTP"</span>];
    }

    requestItem(item) {
        <span class="hljs-comment">// ...</span>
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InventoryRequesterV2</span> </span>{
    <span class="hljs-keyword">constructor</span>() {
        <span class="hljs-keyword">this</span>.REQ_METHODS = [<span class="hljs-string">"WS"</span>];
    }

    requestItem(item) {
        <span class="hljs-comment">// ...</span>
    }
}

<span class="hljs-comment">// By constructing our dependencies externally and injecting them, we can easily</span>
<span class="hljs-comment">// substitute our request module for a fancy new one that uses WebSockets.</span>
<span class="hljs-keyword">const</span> inventoryTracker = <span class="hljs-keyword">new</span> InventoryTracker(
    [<span class="hljs-string">"apples"</span>, <span class="hljs-string">"bananas"</span>],
    <span class="hljs-keyword">new</span> InventoryRequesterV2()
);
inventoryTracker.requestItems();
</div></code></pre>
<a for="toc-anchor" id="%3Etesting%3E"></a><h2 id="blockquotetestingblockquote-8">&gt;Testing&gt;</h2>
<p>Testing is more important than shipping. If you have no tests or an
inadequate amount, then every time you ship code you won't be sure that you
didn't break anything. Deciding on what constitutes an adequate amount is up
to your team, but having 100% coverage (all statements and branches) is how
you achieve very high confidence and developer peace of mind. This means that
in addition to having a great testing framework, you also need to use a
<a href="https://gotwarlost.github.io/istanbul/">good coverage tool</a>.</p>
<p>There's no excuse to not write tests. There are <a href="https://jstherightway.org/#testing-tools">plenty of good JS test frameworks</a>, so find one that your team prefers.
When you find one that works for your team, then aim to always write tests
for every new feature/module you introduce. If your preferred method is
Test Driven Development (TDD), that is great, but the main point is to just
make sure you are reaching your coverage goals before launching any feature,
or refactoring an existing one.</p>
<hr>
<a for="toc-anchor" id="single-concept-per-test"></a><h2 id="single-concept-per-test-51">Single concept per test</h2>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">"assert"</span>;

describe(<span class="hljs-string">"MomentJS"</span>, () =&gt; {
    it(<span class="hljs-string">"handles date boundaries"</span>, () =&gt; {
        <span class="hljs-keyword">let</span> date;

        date = <span class="hljs-keyword">new</span> MomentJS(<span class="hljs-string">"1/1/2015"</span>);
        date.addDays(<span class="hljs-number">30</span>);
        assert.equal(<span class="hljs-string">"1/31/2015"</span>, date);

        date = <span class="hljs-keyword">new</span> MomentJS(<span class="hljs-string">"2/1/2016"</span>);
        date.addDays(<span class="hljs-number">28</span>);
        assert.equal(<span class="hljs-string">"02/29/2016"</span>, date);

        date = <span class="hljs-keyword">new</span> MomentJS(<span class="hljs-string">"2/1/2015"</span>);
        date.addDays(<span class="hljs-number">28</span>);
        assert.equal(<span class="hljs-string">"03/01/2015"</span>, date);
    });
});
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">"assert"</span>;

describe(<span class="hljs-string">"MomentJS"</span>, () =&gt; {
    it(<span class="hljs-string">"handles 30-day months"</span>, () =&gt; {
        <span class="hljs-keyword">const</span> date = <span class="hljs-keyword">new</span> MomentJS(<span class="hljs-string">"1/1/2015"</span>);
        date.addDays(<span class="hljs-number">30</span>);
        assert.equal(<span class="hljs-string">"1/31/2015"</span>, date);
    });

    it(<span class="hljs-string">"handles leap year"</span>, () =&gt; {
        <span class="hljs-keyword">const</span> date = <span class="hljs-keyword">new</span> MomentJS(<span class="hljs-string">"2/1/2016"</span>);
        date.addDays(<span class="hljs-number">28</span>);
        assert.equal(<span class="hljs-string">"02/29/2016"</span>, date);
    });

    it(<span class="hljs-string">"handles non-leap year"</span>, () =&gt; {
        <span class="hljs-keyword">const</span> date = <span class="hljs-keyword">new</span> MomentJS(<span class="hljs-string">"2/1/2015"</span>);
        date.addDays(<span class="hljs-number">28</span>);
        assert.equal(<span class="hljs-string">"03/01/2015"</span>, date);
    });
});
</div></code></pre>
<a for="toc-anchor" id="%3Econcurrency%3E"></a><h2 id="blockquoteconcurrencyblockquote-8">&gt;Concurrency&gt;</h2>
<hr>
<a for="toc-anchor" id="use-promises%2C-not-callbacks"></a><h2 id="use-promises-not-callbacks-51">Use Promises, not callbacks</h2>
<p>Callbacks aren't clean, and they cause excessive amounts of nesting. With ES2015/ES6,
Promises are a built-in global type. Use them!</p>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-keyword">import</span> {
    <span class="hljs-keyword">get</span>
} from "request";
import {
    writeFile
} <span class="hljs-keyword">from</span> <span class="hljs-string">"fs"</span>;

<span class="hljs-keyword">get</span>(
    "https://en.wikipedia.org/wiki/Robert_Cecil_Martin",
    (requestErr, response, body) =&gt; {
        <span class="hljs-keyword">if</span> (requestErr) {
            <span class="hljs-built_in">console</span>.error(requestErr);
        } <span class="hljs-keyword">else</span> {
            writeFile(<span class="hljs-string">"article.html"</span>, body, writeErr =&gt; {
                <span class="hljs-keyword">if</span> (writeErr) {
                    <span class="hljs-built_in">console</span>.error(writeErr);
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"File written"</span>);
                }
            });
        }
    }
);
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-keyword">import</span> {
    <span class="hljs-keyword">get</span>
} from "request-promise";
import {
    writeFile
} <span class="hljs-keyword">from</span> <span class="hljs-string">"fs-extra"</span>;

<span class="hljs-keyword">get</span>("https://en.wikipedia.org/wiki/Robert_Cecil_Martin")
    .then(body =&gt; {
        <span class="hljs-keyword">return</span> writeFile(<span class="hljs-string">"article.html"</span>, body);
    })
    .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"File written"</span>);
    })
    .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.error(err);
    });
</div></code></pre>
<hr>
<a for="toc-anchor" id="async%2Fawait-are-even-cleaner-than-promises"></a><h2 id="asyncawait-are-even-cleaner-than-promises-51">Async/Await are even cleaner than Promises</h2>
<p>Promises are a very clean alternative to callbacks, but ES2017/ES8 brings async and await
which offer an even cleaner solution. All you need is a function that is prefixed
in an <code>async</code> keyword, and then you can write your logic imperatively without
a <code>then</code> chain of functions. Use this if you can take advantage of ES2017/ES8 features
today!</p>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-keyword">import</span> {
    <span class="hljs-keyword">get</span>
} from "request-promise";
import {
    writeFile
} <span class="hljs-keyword">from</span> <span class="hljs-string">"fs-extra"</span>;

<span class="hljs-keyword">get</span>("https://en.wikipedia.org/wiki/Robert_Cecil_Martin")
    .then(body =&gt; {
        <span class="hljs-keyword">return</span> writeFile(<span class="hljs-string">"article.html"</span>, body);
    })
    .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"File written"</span>);
    })
    .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.error(err);
    });
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-keyword">import</span> {
    <span class="hljs-keyword">get</span>
} from "request-promise";
import {
    writeFile
} <span class="hljs-keyword">from</span> <span class="hljs-string">"fs-extra"</span>;

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCleanCodeArticle</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> body = <span class="hljs-keyword">await</span> <span class="hljs-keyword">get</span>(
            "https://en.wikipedia.org/wiki/Robert_Cecil_Martin"
        );
        await writeFile("article.html", body);
        console.log("File written");
    } catch (err) {
        <span class="hljs-built_in">console</span>.error(err);
    }
}

getCleanCodeArticle()
</div></code></pre>
<a for="toc-anchor" id="%3Eerror-handling%3E"></a><h2 id="blockquoteerror-handlingblockquote-8">&gt;Error Handling&gt;</h2>
<p>Thrown errors are a good thing! They mean the runtime has successfully
identified when something in your program has gone wrong and it's letting
you know by stopping function execution on the current stack, killing the
process (in Node), and notifying you in the console with a stack trace.</p>
<hr>
<a for="toc-anchor" id="don't-ignore-caught-errors"></a><h2 id="dont-ignore-caught-errors-51">Don't ignore caught errors</h2>
<p>Doing nothing with a caught error doesn't give you the ability to ever fix
or react to said error. Logging the error to the console ( <code>console.log</code> )
isn't much better as often times it can get lost in a sea of things printed
to the console. If you wrap any bit of code in a <code>try/catch</code> it means you
think an error may occur there and therefore you should have a plan,
or create a code path, for when it occurs.</p>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-keyword">try</span> {
    functionThatMightThrow();
} <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-built_in">console</span>.log(error);
}
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-keyword">try</span> {
    functionThatMightThrow();
} <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// One option (more noisy than console.log):</span>
    <span class="hljs-built_in">console</span>.error(error);
    <span class="hljs-comment">// Another option:</span>
    notifyUserOfError(error);
    <span class="hljs-comment">// Another option:</span>
    reportErrorToService(error);
    <span class="hljs-comment">// OR do all three!</span>
}
</div></code></pre>
<hr>
<a for="toc-anchor" id="don't-ignore-rejected-promises"></a><h2 id="dont-ignore-rejected-promises-51">Don't ignore rejected promises</h2>
<p>For the same reason you shouldn't ignore caught errors
from <code>try/catch</code> .</p>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div>getdata()
    .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
        functionThatMightThrow(data);
    })
    .catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(error);
    });
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div>getdata()
    .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
        functionThatMightThrow(data);
    })
    .catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
        <span class="hljs-comment">// One option (more noisy than console.log):</span>
        <span class="hljs-built_in">console</span>.error(error);
        <span class="hljs-comment">// Another option:</span>
        notifyUserOfError(error);
        <span class="hljs-comment">// Another option:</span>
        reportErrorToService(error);
        <span class="hljs-comment">// OR do all three!</span>
    });
</div></code></pre>
<a for="toc-anchor" id="%3Eformatting%3E"></a><h2 id="blockquoteformattingblockquote-8">&gt;Formatting&gt;</h2>
<p>Formatting is subjective. Like many rules herein, there is no hard and fast
rule that you must follow. The main point is DO NOT ARGUE over formatting.
There are <a href="https://standardjs.com/rules.html">tons of tools</a> to automate this.
Use one! It's a waste of time and money for engineers to argue over formatting.</p>
<p>For things that don't fall under the purview of automatic formatting
(indentation, tabs vs. spaces, double vs. single quotes, etc.) look here
for some guidance.</p>
<hr>
<a for="toc-anchor" id="use-consistent-capitalization"></a><h2 id="use-consistent-capitalization-51">Use consistent capitalization</h2>
<p>JavaScript is untyped, so capitalization tells you a lot about your variables,
functions, etc. These rules are subjective, so your team can choose whatever
they want. The point is, no matter what you all choose, just be consistent.</p>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-keyword">const</span> DAYS_IN_WEEK = <span class="hljs-number">7</span>;
<span class="hljs-keyword">const</span> daysInMonth = <span class="hljs-number">30</span>;

<span class="hljs-keyword">const</span> songs = [<span class="hljs-string">"Back In Black"</span>, <span class="hljs-string">"Stairway to Heaven"</span>, <span class="hljs-string">"Hey Jude"</span>];
<span class="hljs-keyword">const</span> Artists = [<span class="hljs-string">"ACDC"</span>, <span class="hljs-string">"Led Zeppelin"</span>, <span class="hljs-string">"The Beatles"</span>];

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eraseDatabase</span>(<span class="hljs-params"></span>) </span>{}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">restore_database</span>(<span class="hljs-params"></span>) </span>{}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">animal</span> </span>{}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Alpaca</span> </span>{}
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-keyword">const</span> DAYS_IN_WEEK = <span class="hljs-number">7</span>;
<span class="hljs-keyword">const</span> DAYS_IN_MONTH = <span class="hljs-number">30</span>;

<span class="hljs-keyword">const</span> SONGS = [<span class="hljs-string">"Back In Black"</span>, <span class="hljs-string">"Stairway to Heaven"</span>, <span class="hljs-string">"Hey Jude"</span>];
<span class="hljs-keyword">const</span> ARTISTS = [<span class="hljs-string">"ACDC"</span>, <span class="hljs-string">"Led Zeppelin"</span>, <span class="hljs-string">"The Beatles"</span>];

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eraseDatabase</span>(<span class="hljs-params"></span>) </span>{}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">restoreDatabase</span>(<span class="hljs-params"></span>) </span>{}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Alpaca</span> </span>{}
</div></code></pre>
<hr>
<a for="toc-anchor" id="function-callers-and-callees-should-be-close"></a><h2 id="function-callers-and-callees-should-be-close-51">Function callers and callees should be close</h2>
<p>If a function calls another, keep those functions vertically close in the source
file. Ideally, keep the caller right above the callee. We tend to read code from
top-to-bottom, like a newspaper. Because of this, make your code read that way.</p>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PerformanceReview</span> </span>{
    <span class="hljs-keyword">constructor</span>(employee) {
        <span class="hljs-keyword">this</span>.employee = employee;
    }

    lookupPeers() {
        <span class="hljs-keyword">return</span> db.lookup(<span class="hljs-keyword">this</span>.employee, <span class="hljs-string">"peers"</span>);
    }

    lookupManager() {
        <span class="hljs-keyword">return</span> db.lookup(<span class="hljs-keyword">this</span>.employee, <span class="hljs-string">"manager"</span>);
    }

    getPeerReviews() {
        <span class="hljs-keyword">const</span> peers = <span class="hljs-keyword">this</span>.lookupPeers();
        <span class="hljs-comment">// ...</span>
    }

    perfReview() {
        <span class="hljs-keyword">this</span>.getPeerReviews();
        <span class="hljs-keyword">this</span>.getManagerReview();
        <span class="hljs-keyword">this</span>.getSelfReview();
    }

    getManagerReview() {
        <span class="hljs-keyword">const</span> manager = <span class="hljs-keyword">this</span>.lookupManager();
    }

    getSelfReview() {
        <span class="hljs-comment">// ...</span>
    }
}

<span class="hljs-keyword">const</span> review = <span class="hljs-keyword">new</span> PerformanceReview(employee);
review.perfReview();
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PerformanceReview</span> </span>{
    <span class="hljs-keyword">constructor</span>(employee) {
        <span class="hljs-keyword">this</span>.employee = employee;
    }

    perfReview() {
        <span class="hljs-keyword">this</span>.getPeerReviews();
        <span class="hljs-keyword">this</span>.getManagerReview();
        <span class="hljs-keyword">this</span>.getSelfReview();
    }

    getPeerReviews() {
        <span class="hljs-keyword">const</span> peers = <span class="hljs-keyword">this</span>.lookupPeers();
        <span class="hljs-comment">// ...</span>
    }

    lookupPeers() {
        <span class="hljs-keyword">return</span> db.lookup(<span class="hljs-keyword">this</span>.employee, <span class="hljs-string">"peers"</span>);
    }

    getManagerReview() {
        <span class="hljs-keyword">const</span> manager = <span class="hljs-keyword">this</span>.lookupManager();
    }

    lookupManager() {
        <span class="hljs-keyword">return</span> db.lookup(<span class="hljs-keyword">this</span>.employee, <span class="hljs-string">"manager"</span>);
    }

    getSelfReview() {
        <span class="hljs-comment">// ...</span>
    }
}

<span class="hljs-keyword">const</span> review = <span class="hljs-keyword">new</span> PerformanceReview(employee);
review.perfReview();
</div></code></pre>
<a for="toc-anchor" id="%3Ecomments%3E"></a><h2 id="blockquotecommentsblockquote-8">&gt;Comments&gt;</h2>
<hr>
<a for="toc-anchor" id="only-comment-things-that-have-business-logic-complexity."></a><h2 id="only-comment-things-that-have-business-logic-complexity-51">Only comment things that have business logic complexity.</h2>
<p>Comments are an apology, not a requirement. Good code <u>mostly</u> documents itself.</p>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hashIt</span>(<span class="hljs-params">data</span>) </span>{
    <span class="hljs-comment">// The hash</span>
    <span class="hljs-keyword">let</span> hash = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// Length of string</span>
    <span class="hljs-keyword">const</span> length = data.length;

    <span class="hljs-comment">// Loop through every character in data</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
        <span class="hljs-comment">// Get character code.</span>
        <span class="hljs-keyword">const</span> char = data.charCodeAt(i);
        <span class="hljs-comment">// Make the hash</span>
        hash = (hash &lt;&lt; <span class="hljs-number">5</span>) - hash + char;
        <span class="hljs-comment">// Convert to 32-bit integer</span>
        hash &amp;= hash;
    }
}
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hashIt</span>(<span class="hljs-params">data</span>) </span>{
    <span class="hljs-keyword">let</span> hash = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">const</span> length = data.length;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
        <span class="hljs-keyword">const</span> char = data.charCodeAt(i);
        hash = (hash &lt;&lt; <span class="hljs-number">5</span>) - hash + char;

        <span class="hljs-comment">// Convert to 32-bit integer</span>
        hash &amp;= hash;
    }
}
</div></code></pre>
<hr>
<a for="toc-anchor" id="don't-leave-commented-out-code-in-your-codebase"></a><h2 id="dont-leave-commented-out-code-in-your-codebase-51">Don't leave commented out code in your codebase</h2>
<p>Version control exists for a reason. Leave old code in your history.</p>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div>doStuff();
<span class="hljs-comment">// doOtherStuff();</span>
<span class="hljs-comment">// doSomeMoreStuff();</span>
<span class="hljs-comment">// doSoMuchStuff();</span>
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div>doStuff();
</div></code></pre>
<hr>
<a for="toc-anchor" id="don't-have-journal-comments"></a><h2 id="dont-have-journal-comments-51">Don't have journal comments</h2>
<p>Remember, use version control! There's no need for dead code, commented code,
and especially journal comments. Use <code>git log</code> to get history!</p>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div>/&gt;
 * <span class="hljs-number">2016</span><span class="hljs-number">-12</span><span class="hljs-number">-20</span>: Removed monads, didn<span class="hljs-string">'t understand them (RM)
 * 2016-10-01: Improved using special monads (JP)
 * 2016-02-03: Removed type-checking (LI)
 * 2015-03-14: Added combine with type-checking (JR)
 */
function combine(a, b) {
    return a + b;
}
</span></div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">combine</span>(<span class="hljs-params">a, b</span>) </span>{
    <span class="hljs-keyword">return</span> a + b;
}
</div></code></pre>
<hr>
<a for="toc-anchor" id="avoid-positional-markers"></a><h2 id="avoid-positional-markers-51">Avoid positional markers</h2>
<p>They usually just add noise. Let the functions and variable names along with the
proper indentation and formatting give the visual structure to your code.</p>
<blockquote>
<p>Bad:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-comment">////////////////////////////////////////////////////////////////////////////////</span>
<span class="hljs-comment">// Scope Model Instantiation</span>
<span class="hljs-comment">////////////////////////////////////////////////////////////////////////////////</span>
$scope.model = {
    <span class="hljs-attr">menu</span>: <span class="hljs-string">"foo"</span>,
    <span class="hljs-attr">nav</span>: <span class="hljs-string">"bar"</span>
};

<span class="hljs-comment">////////////////////////////////////////////////////////////////////////////////</span>
<span class="hljs-comment">// Action setup</span>
<span class="hljs-comment">////////////////////////////////////////////////////////////////////////////////</span>
<span class="hljs-keyword">const</span> actions = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// ...</span>
};
</div></code></pre>
<blockquote>
<p>Good:&gt;</p>
</blockquote>
<pre><code class="language-javascript"><div>$scope.model = {
    <span class="hljs-attr">menu</span>: <span class="hljs-string">"foo"</span>,
    <span class="hljs-attr">nav</span>: <span class="hljs-string">"bar"</span>
};

<span class="hljs-keyword">const</span> actions = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// ...</span>
};
</div></code></pre>
<hr>
<hr>
<ol>
<li><a name="whitespace">Whitespace</a></li>
</ol>
<ul>
<li>Never mix spaces and tabs.</li>
<li>When beginning a project, before you write any code, choose between soft indents (spaces) or real tabs, consider this &gt;law&gt;.
<ul>
<li>For readability, I always recommend setting your editor's indent size to two characters — this means two spaces or two spaces representing a real tab.</li>
</ul>
</li>
<li>If your editor supports it, always work with the &quot;show invisibles&quot; setting turned on. The benefits of this practice are:
<ul>
<li>Enforced consistency</li>
<li>Eliminating end of line whitespace</li>
<li>Eliminating blank line whitespace</li>
<li>Commits and diffs that are easier to read</li>
</ul>
</li>
<li>Use <a href="http://editorconfig.org/">Editorconfig</a> when possible.  It supports most IDEs and handles most whitespace settings.</li>
</ul>
<ol start="2">
<li>
<p><a name="spacing">Beautiful Syntax</a></p>
<p>A. Parens, Braces, Linebreaks</p>
</li>
</ol>
<pre><code class="language-javascript"><div><span class="hljs-comment">// if/else/for/while/try always have spaces, braces and span multiple lines</span>
<span class="hljs-comment">// this encourages readability</span>

<span class="hljs-comment">// 2.A.1.1</span>
<span class="hljs-comment">// Examples of really cramped syntax</span>

<span class="hljs-keyword">if</span> (condition) doSomething();

<span class="hljs-keyword">while</span> (condition) iterating++;

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) someIterativeFn();

<span class="hljs-comment">// 2.A.1.1</span>
<span class="hljs-comment">// Use whitespace to promote readability</span>

<span class="hljs-keyword">if</span> (condition) {
    <span class="hljs-comment">// statements</span>
}

<span class="hljs-keyword">while</span> (condition) {
    <span class="hljs-comment">// statements</span>
}

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) {
    <span class="hljs-comment">// statements</span>
}

<span class="hljs-comment">// Even better:</span>

<span class="hljs-keyword">var</span> i,
    length = <span class="hljs-number">100</span>;

<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; length; i++) {
    <span class="hljs-comment">// statements</span>
}

<span class="hljs-comment">// Or...</span>

<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>,
    length = <span class="hljs-number">100</span>;

<span class="hljs-keyword">for</span> (; i &lt; length; i++) {
    <span class="hljs-comment">// statements</span>
}

<span class="hljs-keyword">var</span> prop;

<span class="hljs-keyword">for</span> (prop <span class="hljs-keyword">in</span> object) {
    <span class="hljs-comment">// statements</span>
}

<span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-comment">// statements</span>
} <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// statements</span>
}
</div></code></pre>
<pre><code>B. Assignments, Declarations, Functions ( Named, Expression, Constructor )
</code></pre>
<pre><code class="language-javascript"><div><span class="hljs-comment">// 2.B.1.1</span>
<span class="hljs-comment">// Variables</span>
<span class="hljs-keyword">var</span> foo = <span class="hljs-string">"bar"</span>,
    num = <span class="hljs-number">1</span>,
    undef;

<span class="hljs-comment">// Literal notations:</span>
<span class="hljs-keyword">var</span> array = [],
    object = {};

<span class="hljs-comment">// 2.B.1.2</span>
<span class="hljs-comment">// Using only one `var` per scope (function) or one `var` for each variable,</span>
<span class="hljs-comment">// promotes readability and keeps your declaration list free of clutter.</span>
<span class="hljs-comment">// Using one `var` per variable you can take more control of your versions</span>
<span class="hljs-comment">// and makes it easier to reorder the lines.</span>
<span class="hljs-comment">// One `var` per scope makes it easier to detect undeclared variables</span>
<span class="hljs-comment">// that may become implied globals.</span>
<span class="hljs-comment">// Choose better for your project and never mix them.</span>

<span class="hljs-comment">// Bad</span>
<span class="hljs-keyword">var</span> foo = <span class="hljs-string">""</span>,
    bar = <span class="hljs-string">""</span>;
<span class="hljs-keyword">var</span> qux;

<span class="hljs-comment">// Good</span>
<span class="hljs-keyword">var</span> foo = <span class="hljs-string">""</span>;
<span class="hljs-keyword">var</span> bar = <span class="hljs-string">""</span>;
<span class="hljs-keyword">var</span> qux;

<span class="hljs-comment">// or..</span>
<span class="hljs-keyword">var</span> foo = <span class="hljs-string">""</span>,
    bar = <span class="hljs-string">""</span>,
    qux;

<span class="hljs-comment">// or..</span>
<span class="hljs-keyword">var</span> <span class="hljs-comment">// Comment on these</span>
    foo = <span class="hljs-string">""</span>,
    bar = <span class="hljs-string">""</span>,
    quux;

<span class="hljs-comment">// 2.B.1.3</span>
<span class="hljs-comment">// var statements should always be in the beginning of their respective scope (function).</span>

<span class="hljs-comment">// Bad</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{

    <span class="hljs-comment">// some statements here</span>

    <span class="hljs-keyword">var</span> bar = <span class="hljs-string">""</span>,
        qux;
}

<span class="hljs-comment">// Good</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> bar = <span class="hljs-string">""</span>,
        qux;

    <span class="hljs-comment">// all statements after the variables declarations.</span>
}

<span class="hljs-comment">// 2.B.1.4</span>
<span class="hljs-comment">// const and let, from ECMAScript 6, should likewise be at the top of their scope (block).</span>

<span class="hljs-comment">// Bad</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">let</span> foo,
        bar;
    <span class="hljs-keyword">if</span> (condition) {
        bar = <span class="hljs-string">""</span>;
        <span class="hljs-comment">// statements</span>
    }
}
<span class="hljs-comment">// Good</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">let</span> foo;
    <span class="hljs-keyword">if</span> (condition) {
        <span class="hljs-keyword">let</span> bar = <span class="hljs-string">""</span>;
        <span class="hljs-comment">// statements</span>
    }
}
</div></code></pre>
<pre><code class="language-javascript"><div><span class="hljs-comment">// 2.B.2.1</span>
<span class="hljs-comment">// Named Function Declaration</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">arg1, argN</span>) </span>{

}

<span class="hljs-comment">// Usage</span>
foo(arg1, argN);

<span class="hljs-comment">// 2.B.2.2</span>
<span class="hljs-comment">// Named Function Declaration</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">square</span>(<span class="hljs-params">number</span>) </span>{
    <span class="hljs-keyword">return</span> number * number;
}

<span class="hljs-comment">// Usage</span>
square(<span class="hljs-number">10</span>);

<span class="hljs-comment">// Really contrived continuation passing style</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">square</span>(<span class="hljs-params">number, callback</span>) </span>{
    callback(number * number);
}

square(<span class="hljs-number">10</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">square</span>) </span>{
    <span class="hljs-comment">// callback statements</span>
});

<span class="hljs-comment">// 2.B.2.3</span>
<span class="hljs-comment">// Function Expression</span>
<span class="hljs-keyword">var</span> square = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">number</span>) </span>{
    <span class="hljs-comment">// Return something valuable and relevant</span>
    <span class="hljs-keyword">return</span> number * number;
};

<span class="hljs-comment">// Function Expression with Identifier</span>
<span class="hljs-comment">// This preferred form has the added value of being</span>
<span class="hljs-comment">// able to call itself and have an identity in stack traces:</span>
<span class="hljs-keyword">var</span> factorial = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">factorial</span>(<span class="hljs-params">number</span>) </span>{
    <span class="hljs-keyword">if</span> (number &lt; <span class="hljs-number">2</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }

    <span class="hljs-keyword">return</span> number * factorial(number - <span class="hljs-number">1</span>);
};

<span class="hljs-comment">// 2.B.2.4</span>
<span class="hljs-comment">// Constructor Declaration</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FooBar</span>(<span class="hljs-params">options</span>) </span>{

    <span class="hljs-keyword">this</span>.options = options;
}

<span class="hljs-comment">// Usage</span>
<span class="hljs-keyword">var</span> fooBar = <span class="hljs-keyword">new</span> FooBar({
    <span class="hljs-attr">a</span>: <span class="hljs-string">"alpha"</span>
});

fooBar.options;
<span class="hljs-comment">// { a: "alpha" }</span>
</div></code></pre>
<pre><code>C. Exceptions, Slight Deviations
</code></pre>
<pre><code class="language-javascript"><div><span class="hljs-comment">// 2.C.1.1</span>
<span class="hljs-comment">// Functions with callbacks</span>
foo(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// Note there is no extra space between the first paren</span>
    <span class="hljs-comment">// of the executing function call and the word "function"</span>
});

<span class="hljs-comment">// Function accepting an array, no space</span>
foo([<span class="hljs-string">"alpha"</span>, <span class="hljs-string">"beta"</span>]);

<span class="hljs-comment">// 2.C.1.2</span>
<span class="hljs-comment">// Function accepting an object, no space</span>
foo({
    <span class="hljs-attr">a</span>: <span class="hljs-string">"alpha"</span>,
    <span class="hljs-attr">b</span>: <span class="hljs-string">"beta"</span>
});

<span class="hljs-comment">// Single argument string literal, no space</span>
foo(<span class="hljs-string">"bar"</span>);

<span class="hljs-comment">// Expression parens, no space</span>
<span class="hljs-keyword">if</span> (!(<span class="hljs-string">"foo"</span> <span class="hljs-keyword">in</span> obj)) {
    obj = (obj.bar || defaults).baz;
}
</div></code></pre>
<pre><code>D. Consistency Always Wins

In sections 2.A-2.C, the whitespace rules are set forth as a recommendation with a simpler, higher purpose: consistency.
It's important to note that formatting preferences, such as &quot;inner whitespace&quot; should be considered optional, but only one style should exist across the entire source of your project.
</code></pre>
<pre><code class="language-javascript"><div><span class="hljs-comment">// 2.D.1.1</span>

<span class="hljs-keyword">if</span> (condition) {
    <span class="hljs-comment">// statements</span>
}

<span class="hljs-keyword">while</span> (condition) {
    <span class="hljs-comment">// statements</span>
}

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) {
    <span class="hljs-comment">// statements</span>
}

<span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-comment">// statements</span>
} <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// statements</span>
}
</div></code></pre>
<pre><code>E. Quotes

Whether you prefer single or double shouldn't matter, there is no difference in how JavaScript parses them. What &gt;ABSOLUTELY MUST&gt; be enforced is consistency. &gt;Never mix quotes in the same project. Pick one style and stick with it.&gt;

F. End of Lines and Empty Lines

Whitespace can ruin diffs and make changesets impossible to read. Consider incorporating a pre-commit hook that removes end-of-line whitespace and blanks spaces on empty lines automatically.
</code></pre>
<ol start="3">
<li>
<p><a name="type">Type Checking (Courtesy jQuery Core Style Guidelines)</a></p>
<p>A. Actual Types</p>
<p>String:</p>
<pre><code> typeof variable === &quot;string&quot;
</code></pre>
<p>Number:</p>
<pre><code> typeof variable === &quot;number&quot;
</code></pre>
<p>Boolean:</p>
<pre><code> typeof variable === &quot;boolean&quot;
</code></pre>
<p>Object:</p>
<pre><code> typeof variable === &quot;object&quot;
</code></pre>
<p>Array:</p>
<pre><code> Array.isArray( arrayLikeObject )
 (wherever possible)
</code></pre>
<p>Node:</p>
<pre><code> elem.nodeType === 1
</code></pre>
<p>null:</p>
<pre><code> variable === null
</code></pre>
<p>null or undefined:</p>
<pre><code> variable == null
</code></pre>
<p>undefined:</p>
<p>Global Variables:</p>
<pre><code> typeof variable === &quot;undefined&quot;
</code></pre>
<p>Local Variables:</p>
<pre><code> variable === undefined
</code></pre>
<p>Properties:</p>
<pre><code> object.prop === undefined
 object.hasOwnProperty( prop )
 &quot;prop&quot; in object
</code></pre>
<p>B. Coerced Types</p>
<p>Consider the implications of the following...</p>
<p>Given this HTML:</p>
</li>
</ol>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"foo-input"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1"</span>&gt;</span>
</div></code></pre>
<pre><code class="language-javascript"><div><span class="hljs-comment">// 3.B.1.1</span>

<span class="hljs-comment">// `foo` has been declared with the value `0` and its type is `number`</span>
<span class="hljs-keyword">var</span> foo = <span class="hljs-number">0</span>;

<span class="hljs-comment">// typeof foo;</span>
<span class="hljs-comment">// "number"</span>
...

<span class="hljs-comment">// Somewhere later in your code, you need to update `foo`</span>
<span class="hljs-comment">// with a new value derived from an input element</span>

foo = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"foo-input"</span>).value;

<span class="hljs-comment">// If you were to test `typeof foo` now, the result would be `string`</span>
<span class="hljs-comment">// This means that if you had logic that tested `foo` like:</span>

<span class="hljs-keyword">if</span> (foo === <span class="hljs-number">1</span>) {

    importantTask();

}

<span class="hljs-comment">// `importantTask()` would never be evaluated, even though `foo` has a value of "1"</span>

<span class="hljs-comment">// 3.B.1.2</span>

<span class="hljs-comment">// You can preempt issues by using smart coercion with unary + or - operators:</span>

foo = +<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"foo-input"</span>).value;
<span class="hljs-comment">//    ^ unary + operator will convert its right side operand to a number</span>

<span class="hljs-comment">// typeof foo;</span>
<span class="hljs-comment">// "number"</span>

<span class="hljs-keyword">if</span> (foo === <span class="hljs-number">1</span>) {

    importantTask();

}

<span class="hljs-comment">// `importantTask()` will be called</span>
</div></code></pre>
<pre><code>Here are some common cases along with coercions:
</code></pre>
<pre><code class="language-javascript"><div><span class="hljs-comment">// 3.B.2.1</span>

<span class="hljs-keyword">var</span> number = <span class="hljs-number">1</span>,
    string = <span class="hljs-string">"1"</span>,
    bool = <span class="hljs-literal">false</span>;

number;
<span class="hljs-comment">// 1</span>

number + <span class="hljs-string">""</span>;
<span class="hljs-comment">// "1"</span>

string;
<span class="hljs-comment">// "1"</span>

+
string;
<span class="hljs-comment">// 1</span>

+
string++;
<span class="hljs-comment">// 1</span>

string;
<span class="hljs-comment">// 2</span>

bool;
<span class="hljs-comment">// false</span>

+
bool;
<span class="hljs-comment">// 0</span>

bool + <span class="hljs-string">""</span>;
<span class="hljs-comment">// "false"</span>
</div></code></pre>
<pre><code class="language-javascript"><div>    <span class="hljs-comment">// 3.B.2.2</span>

    <span class="hljs-keyword">var</span> number = <span class="hljs-number">1</span>,
        string = <span class="hljs-string">"1"</span>,
        bool = <span class="hljs-literal">true</span>;

    string === number;
    <span class="hljs-comment">// false</span>

    string === number + <span class="hljs-string">""</span>;
    <span class="hljs-comment">// true</span>

    +
    string === number;
    <span class="hljs-comment">// true</span>

    bool === number;
    <span class="hljs-comment">// false</span>

    +
    bool === number;
    <span class="hljs-comment">// true</span>

    bool === string;
    <span class="hljs-comment">// false</span>

    bool === !!string;
    <span class="hljs-comment">// true</span>
</div></code></pre>
<pre><code class="language-javascript"><div>    <span class="hljs-comment">// 3.B.2.3</span>

    <span class="hljs-keyword">var</span> array = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>];

    !!~array.indexOf(<span class="hljs-string">"a"</span>);
    <span class="hljs-comment">// true</span>

    !!~array.indexOf(<span class="hljs-string">"b"</span>);
    <span class="hljs-comment">// true</span>

    !!~array.indexOf(<span class="hljs-string">"c"</span>);
    <span class="hljs-comment">// true</span>

    !!~array.indexOf(<span class="hljs-string">"d"</span>);
    <span class="hljs-comment">// false</span>

    <span class="hljs-comment">// Note that the above should be considered "unnecessarily clever"</span>
    <span class="hljs-comment">// Prefer the obvious approach of comparing the returned value of</span>
    <span class="hljs-comment">// indexOf, like:</span>

    <span class="hljs-keyword">if</span> (array.indexOf(<span class="hljs-string">"a"</span>) &gt;= <span class="hljs-number">0</span>) {
        <span class="hljs-comment">// ...</span>
    }
</div></code></pre>
<pre><code class="language-javascript"><div>    <span class="hljs-comment">// 3.B.2.4</span>

    <span class="hljs-keyword">var</span> num = <span class="hljs-number">2.5</span>;

    <span class="hljs-built_in">parseInt</span>(num, <span class="hljs-number">10</span>);

    <span class="hljs-comment">// is the same as...</span>

    ~~num;

    num &gt;&gt; <span class="hljs-number">0</span>;

    num &gt;&gt;&gt; <span class="hljs-number">0</span>;

    <span class="hljs-comment">// All result in 2</span>

    <span class="hljs-comment">// Keep in mind however, that negative numbers will be treated differently...</span>

    <span class="hljs-keyword">var</span> neg = <span class="hljs-number">-2.5</span>;

    <span class="hljs-built_in">parseInt</span>(neg, <span class="hljs-number">10</span>);

    <span class="hljs-comment">// is the same as...</span>

    ~~neg;

    neg &gt;&gt; <span class="hljs-number">0</span>;

    <span class="hljs-comment">// All result in -2</span>
    <span class="hljs-comment">// However...</span>

    neg &gt;&gt;&gt; <span class="hljs-number">0</span>;

    <span class="hljs-comment">// Will result in 4294967294</span>
</div></code></pre>
<ol start="4">
<li><a name="cond">Conditional Evaluation</a></li>
</ol>
<pre><code class="language-javascript"><div><span class="hljs-comment">// 4.1.1</span>
<span class="hljs-comment">// When only evaluating that an array has length,</span>
<span class="hljs-comment">// instead of this:</span>
<span class="hljs-keyword">if</span> (array.length &gt; <span class="hljs-number">0</span>)...

    <span class="hljs-comment">// ...evaluate truthiness, like this:</span>
    <span class="hljs-keyword">if</span> (array.length)...

        <span class="hljs-comment">// 4.1.2</span>
        <span class="hljs-comment">// When only evaluating that an array is empty,</span>
        <span class="hljs-comment">// instead of this:</span>
        <span class="hljs-keyword">if</span> (array.length === <span class="hljs-number">0</span>)...

            <span class="hljs-comment">// ...evaluate truthiness, like this:</span>
            <span class="hljs-keyword">if</span> (!array.length)...

                <span class="hljs-comment">// 4.1.3</span>
                <span class="hljs-comment">// When only evaluating that a string is not empty,</span>
                <span class="hljs-comment">// instead of this:</span>
                <span class="hljs-keyword">if</span> (string !== <span class="hljs-string">""</span>)...

                    <span class="hljs-comment">// ...evaluate truthiness, like this:</span>
                    <span class="hljs-keyword">if</span> (string)...

                        <span class="hljs-comment">// 4.1.4</span>
                        <span class="hljs-comment">// When only evaluating that a string _is_ empty,</span>
                        <span class="hljs-comment">// instead of this:</span>
                        <span class="hljs-keyword">if</span> (string === <span class="hljs-string">""</span>)...

                            <span class="hljs-comment">// ...evaluate falsy-ness, like this:</span>
                            <span class="hljs-keyword">if</span> (!string)...

                                <span class="hljs-comment">// 4.1.5</span>
                                <span class="hljs-comment">// When only evaluating that a reference is true,</span>
                                <span class="hljs-comment">// instead of this:</span>
                                <span class="hljs-keyword">if</span> (foo === <span class="hljs-literal">true</span>)...

                                    <span class="hljs-comment">// ...evaluate like you mean it, take advantage of built in capabilities:</span>
                                    <span class="hljs-keyword">if</span> (foo)...

                                        <span class="hljs-comment">// 4.1.6</span>
                                        <span class="hljs-comment">// When evaluating that a reference is false,</span>
                                        <span class="hljs-comment">// instead of this:</span>
                                        <span class="hljs-keyword">if</span> (foo === <span class="hljs-literal">false</span>)...

                                            <span class="hljs-comment">// ...use negation to coerce a true evaluation</span>
                                            <span class="hljs-keyword">if</span> (!foo)...

                                                <span class="hljs-comment">// ...Be careful, this will also match: 0, "", null, undefined, NaN</span>
                                                <span class="hljs-comment">// If you _MUST_ test for a boolean false, then use</span>
                                                <span class="hljs-keyword">if</span> (foo === <span class="hljs-literal">false</span>)...

                                                    <span class="hljs-comment">// 4.1.7</span>
                                                    <span class="hljs-comment">// When only evaluating a ref that might be null or undefined, but NOT false, "" or 0,</span>
                                                    <span class="hljs-comment">// instead of this:</span>
                                                    <span class="hljs-keyword">if</span> (foo === <span class="hljs-literal">null</span> || foo === <span class="hljs-literal">undefined</span>)...

                                                        <span class="hljs-comment">// ...take advantage of == type coercion, like this:</span>
                                                        <span class="hljs-keyword">if</span> (foo == <span class="hljs-literal">null</span>)...

                                                            <span class="hljs-comment">// Remember, using == will match a `null` to BOTH `null` and `undefined`</span>
                                                            <span class="hljs-comment">// but not `false` , "" or 0</span>
                                                            <span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span>
</div></code></pre>
<pre><code>ALWAYS evaluate for the best, most accurate result - the above is a guideline, not a dogma.
</code></pre>
<pre><code class="language-javascript"><div><span class="hljs-comment">// 4.2.1</span>
<span class="hljs-comment">// Type coercion and evaluation notes</span>

<span class="hljs-comment">// Prefer `===` over `==` (unless the case requires loose type evaluation)</span>

<span class="hljs-comment">// === does not coerce type, which means that:</span>

<span class="hljs-string">"1"</span> === <span class="hljs-number">1</span>;
<span class="hljs-comment">// false</span>

<span class="hljs-comment">// == does coerce type, which means that:</span>

<span class="hljs-string">"1"</span> == <span class="hljs-number">1</span>;
<span class="hljs-comment">// true</span>

<span class="hljs-comment">// 4.2.2</span>
<span class="hljs-comment">// Booleans, Truthies &amp; Falsies</span>

<span class="hljs-comment">// Booleans:</span>
<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>

    <span class="hljs-comment">// Truthy:</span>
    <span class="hljs-string">"foo"</span>, <span class="hljs-number">1</span>

<span class="hljs-comment">// Falsy:</span>
<span class="hljs-string">""</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">NaN</span>, <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>
</div></code></pre>
<ol start="5">
<li><a name="practical">Practical Style</a></li>
</ol>
<pre><code class="language-javascript"><div><span class="hljs-comment">// 5.1.1</span>
<span class="hljs-comment">// A Practical Module</span>

(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">global</span>) </span>{
    <span class="hljs-keyword">var</span> Module = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{

        <span class="hljs-keyword">var</span> data = <span class="hljs-string">"secret"</span>;

        <span class="hljs-keyword">return</span> {
            <span class="hljs-comment">// This is some boolean property</span>
            bool: <span class="hljs-literal">true</span>,
            <span class="hljs-comment">// Some string value</span>
            string: <span class="hljs-string">"a string"</span>,
            <span class="hljs-comment">// An array property</span>
            array: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],
            <span class="hljs-comment">// An object property</span>
            object: {
                <span class="hljs-attr">lang</span>: <span class="hljs-string">"en-Us"</span>
            },
            <span class="hljs-attr">getData</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-comment">// get the current value of `data`</span>
                <span class="hljs-keyword">return</span> data;
            },
            <span class="hljs-attr">setData</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
                <span class="hljs-comment">// set the value of `data` and return it</span>
                <span class="hljs-keyword">return</span> (data = value);
            }
        };
    })();

    <span class="hljs-comment">// Other things might happen here</span>

    <span class="hljs-comment">// expose our module to the global object</span>
    global.Module = Module;

})(<span class="hljs-keyword">this</span>);
</div></code></pre>
<pre><code class="language-javascript"><div><span class="hljs-comment">// 5.2.1</span>
<span class="hljs-comment">// A Practical Constructor</span>

(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">global</span>) </span>{

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Ctor</span>(<span class="hljs-params">foo</span>) </span>{

        <span class="hljs-keyword">this</span>.foo = foo;

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }

    Ctor.prototype.getFoo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.foo;
    };

    Ctor.prototype.setFoo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>{
        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.foo = val);
    };

    <span class="hljs-comment">// To call constructor's without `new` , you might do this:</span>
    <span class="hljs-keyword">var</span> ctor = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">foo</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Ctor(foo);
    };

    <span class="hljs-comment">// expose our constructor to the global object</span>
    global.ctor = ctor;

})(<span class="hljs-keyword">this</span>);
</div></code></pre>
<ol start="6">
<li>
<p><a name="naming">Naming</a></p>
<p>A. You are not a human code compiler/compressor, so don't try to be one.</p>
<p>The following code is an example of egregious naming:</p>
</li>
</ol>
<pre><code class="language-javascript"><div><span class="hljs-comment">// 6.A.1.1</span>
<span class="hljs-comment">// Example of code with poor names</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">q</span>(<span class="hljs-params">s</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.querySelectorAll(s);
}
<span class="hljs-keyword">var</span> i, a = [],
    els = q(<span class="hljs-string">"#foo"</span>);
<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; els.length; i++) {
    a.push(els[i]);
}
</div></code></pre>
<pre><code>Without a doubt, you've written code like this - hopefully that ends today.

Here's the same piece of logic, but with kinder, more thoughtful naming (and a readable structure):
</code></pre>
<pre><code class="language-javascript"><div><span class="hljs-comment">// 6.A.2.1</span>
<span class="hljs-comment">// Example of code with improved names</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">query</span>(<span class="hljs-params">selector</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.querySelectorAll(selector);
}

<span class="hljs-keyword">var</span> idx = <span class="hljs-number">0</span>,
    elements = [],
    matches = query(<span class="hljs-string">"#foo"</span>),
    length = matches.length;

<span class="hljs-keyword">for</span> (; idx &lt; length; idx++) {
    elements.push(matches[idx]);
}
</div></code></pre>
<pre><code>A few additional naming pointers:
</code></pre>
<pre><code class="language-javascript"><div><span class="hljs-comment">// 6.A.3.1</span>
<span class="hljs-comment">// Naming strings</span>

 <span class="hljs-string">`dog`</span>
is a string

    <span class="hljs-comment">// 6.A.3.2</span>
    <span class="hljs-comment">// Naming arrays</span>

 <span class="hljs-string">`dogs`</span>
is an array <span class="hljs-keyword">of</span> <span class="hljs-string">`dog`</span>
strings

<span class="hljs-comment">// 6.A.3.3</span>
<span class="hljs-comment">// Naming functions, objects, instances, etc</span>

camelCase;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">and</span>
<span class="hljs-title">var</span> <span class="hljs-title">declarations</span>

// 6.<span class="hljs-title">A</span>.3.4
// <span class="hljs-title">Naming</span> <span class="hljs-title">constructors</span>, <span class="hljs-title">prototypes</span>, <span class="hljs-title">etc</span>.

<span class="hljs-title">PascalCase</span>;
<span class="hljs-title">constructor</span>
<span class="hljs-title">function</span>

// 6.<span class="hljs-title">A</span>.3.5
// <span class="hljs-title">Naming</span> <span class="hljs-title">regular</span> <span class="hljs-title">expressions</span>

<span class="hljs-title">rDesc</span> = //;

// 6.<span class="hljs-title">A</span>.3.6
// <span class="hljs-title">From</span> <span class="hljs-title">the</span> <span class="hljs-title">Google</span> <span class="hljs-title">Closure</span> <span class="hljs-title">Library</span> <span class="hljs-title">Style</span> <span class="hljs-title">Guide</span>

<span class="hljs-title">functionNamesLikeThis</span>;
<span class="hljs-title">variableNamesLikeThis</span>;
<span class="hljs-title">ConstructorNamesLikeThis</span>;
<span class="hljs-title">EnumNamesLikeThis</span>;
<span class="hljs-title">methodNamesLikeThis</span>;
<span class="hljs-title">SYMBOLIC_CONSTANTS_LIKE_THIS</span>;
</span></div></code></pre>
<pre><code>B. Faces of `this`
Beyond the generally well known use cases of `call` and `apply` , always prefer `.bind( this )` or a functional equivalent, for creating `BoundFunction` definitions for later invocation. Only resort to aliasing when no preferable option is available.
</code></pre>
<pre><code class="language-javascript"><div><span class="hljs-comment">// 6.B.1</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Device</span>(<span class="hljs-params">opts</span>) </span>{

    <span class="hljs-keyword">this</span>.value = <span class="hljs-literal">null</span>;

    <span class="hljs-comment">// open an async stream,</span>
    <span class="hljs-comment">// this will be called continuously</span>
    stream.read(opts.path, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>{

        <span class="hljs-comment">// Update this instance's current value</span>
        <span class="hljs-comment">// with the most recent value from the</span>
        <span class="hljs-comment">// data stream</span>
        <span class="hljs-keyword">this</span>.value = data;

    }.bind(<span class="hljs-keyword">this</span>));

    <span class="hljs-comment">// Throttle the frequency of events emitted from</span>
    <span class="hljs-comment">// this Device instance</span>
    setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{

        <span class="hljs-comment">// Emit a throttled event</span>
        <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">"event"</span>);

    }.bind(<span class="hljs-keyword">this</span>), opts.freq || <span class="hljs-number">100</span>);
}

<span class="hljs-comment">// Just pretend we've inherited EventEmitter ;)</span>
</div></code></pre>
<pre><code>When unavailable, functional equivalents to `.bind` exist in many modern JavaScript libraries.
</code></pre>
<pre><code class="language-javascript"><div>    <span class="hljs-comment">// 6.B.2</span>

    <span class="hljs-comment">// eg. lodash/underscore, _.bind()</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Device</span>(<span class="hljs-params">opts</span>) </span>{

        <span class="hljs-keyword">this</span>.value = <span class="hljs-literal">null</span>;

        stream.read(opts.path, _.bind(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>{

            <span class="hljs-keyword">this</span>.value = data;

        }, <span class="hljs-keyword">this</span>));

        setInterval(_.bind(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{

            <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">"event"</span>);

        }, <span class="hljs-keyword">this</span>), opts.freq || <span class="hljs-number">100</span>);
    }

    <span class="hljs-comment">// eg. jQuery.proxy</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Device</span>(<span class="hljs-params">opts</span>) </span>{

        <span class="hljs-keyword">this</span>.value = <span class="hljs-literal">null</span>;

        stream.read(opts.path, jQuery.proxy(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>{

            <span class="hljs-keyword">this</span>.value = data;

        }, <span class="hljs-keyword">this</span>));

        setInterval(jQuery.proxy(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{

            <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">"event"</span>);

        }, <span class="hljs-keyword">this</span>), opts.freq || <span class="hljs-number">100</span>);
    }

    <span class="hljs-comment">// eg. dojo.hitch</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Device</span>(<span class="hljs-params">opts</span>) </span>{

        <span class="hljs-keyword">this</span>.value = <span class="hljs-literal">null</span>;

        stream.read(opts.path, dojo.hitch(<span class="hljs-keyword">this</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>{

            <span class="hljs-keyword">this</span>.value = data;

        }));

        setInterval(dojo.hitch(<span class="hljs-keyword">this</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{

            <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">"event"</span>);

        }), opts.freq || <span class="hljs-number">100</span>);
    }
</div></code></pre>
<pre><code>As a last resort, create an alias to `this` using `self` as an Identifier. This is extremely bug prone and should be avoided whenever possible.
</code></pre>
<pre><code class="language-javascript"><div><span class="hljs-comment">// 6.B.3</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Device</span>(<span class="hljs-params">opts</span>) </span>{
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

    <span class="hljs-keyword">this</span>.value = <span class="hljs-literal">null</span>;

    stream.read(opts.path, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>{

        self.value = data;

    });

    setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{

        self.emit(<span class="hljs-string">"event"</span>);

    }, opts.freq || <span class="hljs-number">100</span>);
}
</div></code></pre>
<pre><code>C. Use `thisArg`
Several prototype methods of ES 5.1 built-ins come with a special `thisArg` signature, which should be used whenever possible
</code></pre>
<pre><code class="language-javascript"><div><span class="hljs-comment">// 6.C.1</span>

<span class="hljs-keyword">var</span> obj;

obj = {
    <span class="hljs-attr">f</span>: <span class="hljs-string">"foo"</span>,
    <span class="hljs-attr">b</span>: <span class="hljs-string">"bar"</span>,
    <span class="hljs-attr">q</span>: <span class="hljs-string">"qux"</span>
};

<span class="hljs-built_in">Object</span>.keys(obj).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>{

    <span class="hljs-comment">// |this| now refers to `obj`</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>[key]);

}, obj); <span class="hljs-comment">// &lt;-- the last arg is `thisArg`</span>
<span class="hljs-comment">// Prints...</span>

<span class="hljs-comment">// "foo"</span>
<span class="hljs-comment">// "bar"</span>
<span class="hljs-comment">// "qux"</span>
</div></code></pre>
<a for="toc-anchor" id="%60thisarg%60-can-be-used-with-%60array.prototype.every%60-%2C-%60array.prototype.foreach%60-%2C-%60array.prototype.some%60-%2C-%60array.prototype.map%60-%2C-%60array.prototype.filter%60"></a><h2 id="thisarg-can-be-used-with-arrayprototypeevery--arrayprototypeforeach--arrayprototypesome--arrayprototypemap--arrayprototypefilter-51"><code>thisArg</code> can be used with <code>Array.prototype.every</code> , <code>Array.prototype.forEach</code> , <code>Array.prototype.some</code> , <code>Array.prototype.map</code> , <code>Array.prototype.filter</code></h2>
<hr>
<a for="toc-anchor" id="the-dom"></a><h2 id="the-dom-51">THE DOM</h2>
<p>The Document Object Model (DOM) is an API for HTML and XML documents. It provides a structural representation of the document, enabling you to modify its content and visual presentation by using a scripting language such as JavaScript. See more at <a href="https://developer.mozilla.org/en-US/docs/DOM">Mozilla Developer Network - DOM</a>.</p>
<a for="toc-anchor" id="conventions"></a><h2 id="conventions-51">Conventions</h2>
<p>As every language, JavaScript has many code style guides. Maybe the most used and recommended is the <a href="https://google.github.io/styleguide/javascriptguide.xml">Google Code Style Guide for JavaScript</a>, but we recommend you read <a href="https://github.com/rwldrn/idiomatic.js/">Idiomatic.js</a>.</p>
<a for="toc-anchor" id="linting"></a><h2 id="linting-51">Linting</h2>
<p>Nowadays the best tool for linting your JavaScript code is <a href="http://www.jshint.com/">JSHint</a>. We recommend that whenever possible you verify your code style and patterns with a Lint tool.</p>
<a for="toc-anchor" id="object-oriented"></a><h2 id="object-oriented-51">Object Oriented</h2>
<p>JavaScript has strong object-oriented programming capabilities, even though some debates have taken place due to the differences in object-oriented JavaScript compared to other languages.</p>
<p>Source: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript">Introduction to Object-Oriented JavaScript</a></p>
<a for="toc-anchor" id="anonymous-functions"></a><h2 id="anonymous-functions-51">Anonymous Functions</h2>
<p>Anonymous functions are functions that are dynamically declared at runtime. They're called anonymous functions because they aren't given a name in the same way as normal functions.</p>
<p>Source: <a href="http://helephant.com/2008/08/23/javascript-anonymous-functions/">JavaScript anonymous functions</a></p>
<a for="toc-anchor" id="functions-as-first-class-objects"></a><h2 id="functions-as-first-class-objects-51">Functions as First-class Objects</h2>
<p>Functions in JavaScript are first class objects. This means that JavaScript functions are just a special type of object that can do all the things that regular objects can do.</p>
<p>Source: <a href="http://helephant.com/2008/08/19/functions-are-first-class-objects-in-javascript/">Functions are first class objects in JavaScript</a></p>
<a for="toc-anchor" id="loose-typing"></a><h2 id="loose-typing-51">Loose Typing</h2>
<p>For many front-end developers, JavaScript was their first taste of a scripting and/or interpretive language. To these developers, the concept and implications of loosely typed variables may be second nature. However, the explosive growth in demand for modern web applications has resulted in a growing number of back-end developers that have had to dip their feet into the pool of client-side technologies. Many of these developers are coming from a background of strongly typed languages, such as C# or Java, and are unfamiliar with both the freedom and the potential pitfalls involved in working with loosely typed variables.</p>
<p>Source: <a href="http://blog.jeremymartin.name/2008/03/understanding-loose-typing-in.html">Understanding Loose Typing in JavaScript</a></p>
<a for="toc-anchor" id="scoping-and-hoisting"></a><h2 id="scoping-and-hoisting-51">Scoping and Hoisting</h2>
<blockquote>
<p>Scoping:&gt; In JavaScript, functions are our <u>de facto</u> scope delimiters for declaring vars, which means that usual blocks from loops and conditionals (such as if, for, while, switch and try) DON'T delimit scope, unlike most other languages. Therefore, those blocks will share the same scope as the function which contains them. This way, it might be dangerous to declare vars inside blocks as it would seem the var belongs to that block only.</p>
</blockquote>
<blockquote>
<p>Hoisting:&gt; On runtime, all var and function declarations are moved to the beginning of each function (its scope) - this is known as Hoisting. Having said so, it is a good practice to declare all the vars altogether on the first line, in order to avoid false expectations with a var that got declared late but happened to hold a value before - this is a common problem for programmers coming from languages with block scope.</p>
</blockquote>
<p>Source: <a href="http://www.adequatelygood.com/JavaScript-Scoping-and-Hoisting.html">JavaScript Scoping and Hoisting</a></p>
<a for="toc-anchor" id="function-binding"></a><h2 id="function-binding-51">Function Binding</h2>
<p>Function binding is most probably the least of your concerns when beginning with JavaScript, but when you realize that you need a solution to the problem of how to keep the context of this within another function, then you might realize that what you actually need is &gt;Function.prototype.bind()&gt;.</p>
<p>Source: <a href="http://coding.smashingmagazine.com/2014/01/23/understanding-javascript-function-prototype-bind/">Understanding JavaScript's Function.prototype.bind</a></p>
<a for="toc-anchor" id="closure-function"></a><h2 id="closure-function-51">Closure Function</h2>
<p>Closures are functions that refer to independent (free) variables. In other words, the function defined in the closure 'remembers' the environment in which it was created in. It is an important concept to understand as it can be useful during development, like emulating private methods. It can also help to learn how to avoid common mistakes, like creating closures in loops.</p>
<p>Source: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures/">MDN - Closures</a></p>
<a for="toc-anchor" id="strict-mode"></a><h2 id="strict-mode-51">Strict mode</h2>
<p>ECMAScript 5's strict mode is a way to opt in to a restricted variant of JavaScript. Strict mode isn't just a subset: it intentionally has different semantics from normal code. Browsers not supporting strict mode will run strict mode code with different behavior from browsers that do, so don't rely on strict mode without feature-testing for support for the relevant aspects of strict mode. Strict mode code and non-strict mode code can coexist, so scripts can opt into strict mode incrementally.</p>
<p>Source: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/Strict_mode/">MDN - Strict mode</a></p>
<a for="toc-anchor" id="immediately-invoked-function-expression-(iife)"></a><h2 id="immediately-invoked-function-expression-iife-51">Immediately-Invoked Function Expression (IIFE)</h2>
<p>An immediately-invoked function expression is a pattern which produces a lexical scope using JavaScript's function scoping. Immediately-invoked function expressions can be used to avoid variable hoisting from within blocks, protect against polluting the global environment and simultaneously allow public access to methods while retaining privacy for variables defined within the function.</p>
<p><u>This pattern has been referred to as a self-executing anonymous function, but <a href="http://twitter.com/cowboy">@cowboy</a> (Ben Alman) introduced the term IIFE as a more semantically accurate term for the pattern</u>.</p>
<p>Source: <a href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/">Immediately-Invoked Function Expression (IIFE)</a></p>
<a for="toc-anchor" id="arindam-paul---javascript-vm-internals%2C-eventloop%2C-async-and-scopechains"></a><h4 id="arindam-paul---javascript-vm-internals-eventloop-async-and-scopechains-51">Arindam Paul - JavaScript VM internals, EventLoop, Async and ScopeChains</h4>
<a for="toc-anchor" id="general-purpose"></a><h2 id="general-purpose-51">GENERAL PURPOSE</h2>
<ul>
<li><a href="http://jquery.com/">jQuery</a></li>
</ul>
<p>jQuery is a fast, small, and feature-rich JavaScript library. Built by <a href="https://twitter.com/jeresig">John Resig</a>.</p>
<ul>
<li><a href="http://yuilibrary.com/">YUI</a></li>
</ul>
<p>Built by Yahoo!, YUI is a free, open source JavaScript and CSS library for building richly interactive web applications. <a href="http://yahooeng.tumblr.com/">New development has stopped since August 29th, 2014</a>.</p>
<ul>
<li><a href="http://zeptojs.com/">ZeptoJS</a></li>
</ul>
<p>Zepto is a minimalist JavaScript library for modern browsers with a largely jQuery-compatible API. If you use jQuery, you already know how to use Zepto.</p>
<ul>
<li><a href="http://dojotoolkit.org/">Dojo Toolkit</a></li>
</ul>
<p>Dojo is a free, open-source JavaScript toolkit for building high performance web applications. Project sponsors include IBM and SitePen.</p>
<ul>
<li><a href="http://underscorejs.org/">Underscore.js</a></li>
</ul>
<p>Underscore.js is a JavaScript library that provides a whole mess of useful functional programming helpers without extending any built-in objects.</p>
<a for="toc-anchor" id="mv%5C*"></a><h2 id="mv-51">MV*</h2>
<ul>
<li><a href="http://backbonejs.org/">Backbone.js</a></li>
</ul>
<p>Very popular JavaScript client-side framework, built by <a href="http://twitter.com/jashkenas">@jashkenas</a>.</p>
<ul>
<li><a href="http://emberjs.com/">Ember.js</a></li>
</ul>
<p>Built by <a href="http://twitter.com/wycats">@wycats</a>, jQuery and Ruby on Rails core developer.</p>
<ul>
<li><a href="http://knockoutjs.com/">Knockout.js</a></li>
</ul>
<p>Simplify dynamic JavaScript UIs by applying the Model-View-View Model (MVVM).</p>
<ul>
<li><a href="http://angularjs.org/">Angular.js</a></li>
</ul>
<p>Built by Google, Angular.js is like a polyfill for the future of HTML.</p>
<ul>
<li><a href="https://angular.io/">Angular</a></li>
</ul>
<p>One framework. Mobile &amp; desktop. One way to build applications with Angular and reuse your code and abilities to build apps for any deployment target. For web, mobile web, native mobile and native desktop.</p>
<ul>
<li><a href="http://cappuccino.org/">Cappuccino</a></li>
</ul>
<p>Cappuccino is an open-source framework that makes it easy to build desktop-caliber applications that run in a web browser.</p>
<ul>
<li><a href="http://javascriptmvc.com/">JavaScript MVC</a></li>
</ul>
<p>JavaScriptMVC is an open-source framework containing the best ideas in jQuery development.</p>
<ul>
<li><a href="https://www.meteor.com/">Meteor</a></li>
</ul>
<p>Meteor is an open-source platform for building top-quality web apps in a fraction of the time, whether you're an expert developer or just getting started.</p>
<ul>
<li><a href="http://spicejs.github.io/spicejs/">Spice.js</a></li>
</ul>
<p>Spice is a super minimal (&lt; 3k) and flexible MVC framework for javascript. Spice was built to be easily added to any existent application and play well with other technologies such as jQuery, pjax, turbolinks, node or whatever else you are using.</p>
<ul>
<li><a href="http://www.riotjs.com/">Riot.js</a></li>
</ul>
<p>Riot is an incredibly fast, powerful yet tiny client side (MV*) library for building large scale web applications. Despite the small size all the building blocks are there: a template engine, router, event library and a strict MVP pattern to keep things organized.</p>
<ul>
<li><a href="http://canjs.com/">CanJS</a></li>
</ul>
<p>CanJS is a JavaScript framework that makes developing complex applications simple and fast. Easy-to-learn, small, and unassuming of your application structure, but with modern features like custom tags and 2-way binding.</p>
<a for="toc-anchor" id="library"></a><h2 id="library-51">Library</h2>
<ul>
<li><a href="http://facebook.github.io/react">React</a></li>
</ul>
<p>Built by Facebook. React is a JavaScript library for creating user interfaces by Facebook and Instagram. Many people choose to think of React as the V in MVC.</p>
<ul>
<li><a href="http://www.vuejs.org/">Vue.js</a></li>
</ul>
<p>Is an MVVM library providing two-way data binding, HTML extended behaviour (through directives) and reactive components. By using native add-ons a developer can also have routing, AJAX, a Flux-like state management, form validation and more. Provides a helpful Chrome extension to inspect components built with Vue.</p>
<ul>
<li><a href="http://handlebarsjs.com/">Handlebars</a></li>
</ul>
<p>Handlebars provides the power necessary to let you build semantic templates effectively with no frustration.</p>
<ul>
<li><a href="http://linkedin.github.io/dustjs">Dust.js</a></li>
</ul>
<p>Asynchronous templates for the browser and node.js.</p>
<a for="toc-anchor" id="animation"></a><h2 id="animation-51">Animation</h2>
<ul>
<li><a href="http://greensock.com/">GSAP</a></li>
</ul>
<p>GSAP is the fastest full-featured scripted animation tool on the planet. It's even faster than CSS3 animations and transitions in many cases.</p>
<ul>
<li><a href="http://julian.com/research/velocity/">Velocity.js</a></li>
</ul>
<p>Velocity is an animation engine with the same API as jQuery's $.animate().</p>
<ul>
<li><a href="http://bouncejs.com/">Bounce.js</a></li>
</ul>
<p>Bounce.js is a tool and JS library that lets you create beautiful CSS3 powered animations.</p>
<ul>
<li><a href="http://www.createjs.com/tweenjs">TweenJS</a></li>
</ul>
<p>A simple but powerful JavaScript library for tweening and animating HTML5 and JavaScript properties.</p>
<ul>
<li><a href="http://visionmedia.github.io/move.js/">Move.js</a></li>
</ul>
<p>Move.js is a small JavaScript library making CSS3 backed animation extremely simple and elegant.</p>
<ul>
<li><a href="http://snapsvg.io/">Snap.svg</a></li>
</ul>
<p>SVG is an excellent way to create interactive, resolution-independent vector graphics that will look great on any size screen.</p>
<ul>
<li><a href="http://rekapi.com/">Rekapi</a></li>
</ul>
<p>Rekapi is a library for making canvas and DOM animations with JavaScript, as well as CSS @keyframe animations for modern browsers.</p>
<ul>
<li><a href="http://lab.ejci.net/favico.js/">Favico.js</a></li>
</ul>
<p>Make use of your favicon with badges, images or videos.</p>
<ul>
<li><a href="http://jschr.github.io/textillate/">Textillate.js</a></li>
</ul>
<p>Textillate.js combines some awesome libraries to provide a ease-to-use plugin for applying CSS3 animations to any text.</p>
<ul>
<li><a href="http://darsa.in/motio/">Motio</a></li>
</ul>
<p>Motio is a small JavaScript library for simple but powerful sprite based animations and panning.</p>
<ul>
<li><a href="http://lvivski.com/anima/">Anima.js</a></li>
</ul>
<p>With Anima it's easy to animate over a hundred objects at a time. Each item can have it's mass and viscosity to emulate reallife objects!</p>
<ul>
<li><a href="http://melonjs.org/">MelonJS</a></li>
</ul>
<p>MelonJS is a free, light-weight HTML5 game engine. The engine integrates the tiled map format making level design easier.</p>
<ul>
<li><a href="http://impactjs.com/">ImpactJS</a></li>
</ul>
<p>ImpactJS is one of the more tested-and-true HTML5 game engines with the initial release all the way back at the end of 2010. It is very well maintained and updated, and has a good-sized community backing it. There exists plenty of documentation - even two books on the subject of creating games with the engine.</p>
<ul>
<li><a href="http://limejs.com/">LimeJS</a></li>
</ul>
<p>LimeJS is a HTML5 game framework for building fast, native-experience games for all modern touchscreens and desktop browsers.</p>
<ul>
<li><a href="http://craftyjs.com/">Crafty</a></li>
</ul>
<p>Crafty is a game engine that dates back to late 2010. Crafty makes it really easy to get started making JavaScript games.</p>
<ul>
<li><a href="http://www.cocos2d-x.org/wiki/Cocos2d-html5">Cocos2d-HTML5</a></li>
</ul>
<p>Cocos2d-html5 is an open-source web 2D game framework, released under MIT License. It is a HTML5 version of Cocos2d-x project. The focus for Cocos2d-html5 development is around making Cocos2d cross platforms between browsers and native application.</p>
<ul>
<li><a href="http://phaser.io/">Phaser</a></li>
</ul>
<p>Phaser is based heavily on <a href="http://www.flixel.org/">Flixel</a>. It is maintained by Richard Davey (<a href="http://www.photonstorm.com/">Photon Storm</a>) who has been very active in the HTML5 community for years.</p>
<ul>
<li><a href="http://www.goocreate.com/learn">Goo</a></li>
</ul>
<p>Goo is a 3D JavaScript gaming engine entirely built on WebGL/HTML5</p>
<ul>
<li><a href="http://lycheejs.org/">LycheeJS</a></li>
</ul>
<p>LycheeJS is a JavaScript Game library that offers a complete solution for prototyping and deployment of HTML5 Canvas, WebGL or native OpenGL(ES) based games inside the Web Browser or native environments.</p>
<ul>
<li><a href="http://html5quintus.com/">Quintus</a></li>
</ul>
<p>Quintus is an HTML5 game engine designed to be modular and lightweight, with a concise JavaScript-friendly syntax.</p>
<ul>
<li><a href="http://www.kiwijs.org/">KiwiJS</a></li>
</ul>
<p>Kiwi.js is a fun and friendly Open Source HTML5 Game Engine. Some people call it the WordPress of HTML5 game engines</p>
<ul>
<li><a href="http://www.pandajs.net/">PandaJS</a></li>
</ul>
<p>Panda.js is a HTML5 game engine for mobile and desktop with Canvas and WebGL rendering.</p>
<ul>
<li><a href="https://github.com/ondras/rot.js">Rot.js</a></li>
</ul>
<p>Rot.js is a set of JavaScript libraries, designed to help with a roguelike development in browser environment.</p>
<ul>
<li><a href="http://www.isogenicengine.com/">Isogenic</a></li>
</ul>
<p>Isogenic is an advanced game engine that provides the most advanced networking and realtime multiplayer functionality available in any HTML 5 game engine. The system is based on entity streaming and includes powerful simulation options and client-side entity interpolation from delta updates.</p>
<ul>
<li><a href="https://github.com/WhitestormJS/whitestorm.js">WhitestormJS</a></li>
</ul>
<p>Super-fast 3D framework for Web Applications &amp; Games. Based on Three.js. Includes integrated physics support and ReactJS integration.</p>
<p><a href="https://jstherightway.org/">Source</a></p>
<hr>
<hr>
<a for="toc-anchor" id="the-16-javascript-debugging-tips"></a><h1 id="the-16-javascript-debugging-tips-51">The 16 JavaScript debugging tips</h1>
<a for="toc-anchor" id="debug-javascript-faster"></a><h2 id="debug-javascript-faster-51">Debug JavaScript faster</h2>
<p>Knowing your tools can make a significant difference when it comes to getting things done. Despite JavaScript's reputation as being difficult to debug, if you keep a couple of tricks up your sleeve errors and bugs will take less time to resolve.</p>
<p>We've put together a list of 16 debugging tips that you may not know, but might want to keep in mind for next time you find yourself needing to debug your JavaScript code!</p>
<p><a href="https://raygun.com/platform/crash-reporting">If you need to find your JavaScript bugs faster, try Raygun Crash Reporting, which will alert you to bugs and give the stack trace.</a></p>
<p>Most of these tips are for Chrome and Firefox, although many will also work with other inspectors.</p>
<a for="toc-anchor" id="1%5C.-debugger"></a><h2 id="1-debugger-51">1. debugger</h2>
<p>After console.log, debugger is my favorite quick and dirty debugging tool. If you place a debugger; line in your code, Chrome will automatically stop there when executing. You can even wrap it in conditionals, so it only runs when you need it.</p>
<p>if (thisThing) {<br>
debugger; }</p>
<a for="toc-anchor" id="2%5C.-display-objects-as-a-table"></a><h2 id="2-display-objects-as-a-table-51">2. Display objects as a table</h2>
<p>Sometimes, you have a complex set of objects that you want to view. You can either console.log them and scroll through the list, or break out the console.table helper. It makes it easier to see what you're dealing with!</p>
<p>var animals = [</p>
<pre><code>{ animal: 'Horse', name: 'Henry', age: 43 },
{ animal: 'Dog', name: 'Fred', age: 13 },
{ animal: 'Cat', name: 'Frodo', age: 18 }
</code></pre>
<p>];</p>
<p>console.table(animals);</p>
<p>Will output:</p>
<p><img src="https://assets-global.website-files.com/5e4bb125419b3343f60a3c85/5f235e7897970a9af238fc01_5eaa4c24076841924ce3f5f4_Debugging-2b.png" alt=""></p>
<a for="toc-anchor" id="3%5C.-try-all-the-sizes"></a><h2 id="3-try-all-the-sizes-51">3. Try all the sizes</h2>
<p>While having every single mobile device on your desk would be awesome, it's not feasible in the real world. How about resizing your viewport instead? Chrome provides you with everything you need. Jump into your inspector and click the toggle device mode button. Watch your media queries come to life!</p>
<p><img src="https://assets-global.website-files.com/5e4bb125419b3343f60a3c85/5f235e8b70e96f765748cb45_5eaa4c85fbbd830a55c31d4c_Debugging-1.png" alt=""></p>
<a for="toc-anchor" id="4%5C.-how-to-find-your-dom-elements-quickly"></a><h2 id="4-how-to-find-your-dom-elements-quickly-51">4. How to find your DOM elements quickly</h2>
<p>Mark a DOM element in the elements panel and use it in your console. Chrome Inspector keeps the last five elements in its history so that the final marked element displays with $0, the second to last marked element $1 and so on. If you mark following items in order 'item-4′, 'item-3', 'item-2', 'item-1', 'item-0' then you can access the DOM nodes like this in the console:</p>
<p><img src="https://assets-global.website-files.com/5e4bb125419b3343f60a3c85/5f235e8b5a7f828daf39838c_5eaa4ccfb688d30326ad49a6_Debugging-2.png" alt=""></p>
<a for="toc-anchor" id="5%5C.-benchmark-loops-using-console.time()-and-console.timeend()"></a><h2 id="5-benchmark-loops-using-consoletime-and-consoletimeend-51">5. Benchmark loops using console.time() and console.timeEnd()</h2>
<p>It can be super useful to know exactly how long something has taken to execute, especially when debugging slow loops. You can even set up multiple timers by assigning a label to the method. Let's see how it works:</p>
<p>console.time('Timer1');</p>
<p>var items = [];</p>
<p>for(var i = 0; i &lt; 100000; i++){
items.push({index: i});
}</p>
<p>console.timeEnd('Timer1');</p>
<p>Will output:</p>
<p><img src="https://assets-global.website-files.com/5e4bb125419b3343f60a3c85/5f235e8b780ab4213fe3718f_5eaa4d949ab962f8ea740e53_Debugging-3.png" alt=""></p>
<a for="toc-anchor" id="6%5C.-get-the-stack-trace-for-a-function"></a><h2 id="6-get-the-stack-trace-for-a-function-51">6. Get the stack trace for a function</h2>
<p>You probably know <a href="https://raygun.com/blog/popular-javascript-frameworks/">JavaScript frameworks</a> produce a lot of code – quickly.</p>
<p>You will have a lot of views and be triggering a lot of events, so eventually you will come across a situation where you want to know what caused a particular function call. Since JavaScript is not a very structured language, it can sometimes be hard to get an overview of what happened and when. This is when console.trace (or just trace in the console) comes in handy to be able to debug JavaScript. Imagine you want to see the entire stack trace for the function call funcZ in the car instance on Line 33:</p>
<p>var car;
var func1 = function() {</p>
<pre><code>func2();
</code></pre>
<p>}</p>
<p>var func2 = function() {</p>
<pre><code>func4();
</code></pre>
<p>}
var func3 = function() {
}</p>
<p>var func4 = function() {</p>
<pre><code>car = new Car();
car.funcX();
</code></pre>
<p>}
var Car = function() {</p>
<pre><code>this.brand = 'volvo'; 
this.color = 'red'; 
this.funcX = function() {
    this.funcY(); 
}

this.funcY = function() {
    this.funcZ(); 
}

this.funcZ = function() {
    console.trace('trace car')
}
</code></pre>
<p>}
func1();
var car;
var func1 = function() {</p>
<pre><code>func2();
</code></pre>
<p>}
var func2 = function() {</p>
<pre><code>func4();
</code></pre>
<p>}
var func3 = function() {
}
var func4 = function() {</p>
<pre><code>car = new Car();
car.funcX();
</code></pre>
<p>}
var Car = function() {</p>
<pre><code>this.brand = 'volvo'; 
this.color = 'red'; 
this.funcX = function() {
    this.funcY(); 
}

this.funcY = function() {
    this.funcZ(); 
}

 this.funcZ = function() {
    console.trace('trace car')
}
</code></pre>
<p>}
func1();</p>
<p>‍</p>
<p>Line 33 will output:</p>
<p><img src="https://assets-global.website-files.com/5e4bb125419b3343f60a3c85/5f235e8bb28a6cc3a46c5958_5eaa4e0728b2be06967be396_Debugging-4.png" alt=""></p>
<p>Now we can see that &gt;func1&gt; called &gt;func2, &gt; which called &gt;func4&gt;. &gt;Func4&gt; then created an instance of &gt;Car&gt; and then called the function &gt;car.funcX&gt;, and so on. Even though you think you know your script well this can still be quite handy. Let's say you want to improve your code. Get the trace and your great list of all related functions. Every single one is clickable, and you can now go back and forth between them. It's like a menu just for you.</p>
<a for="toc-anchor" id="7%5C.-unminify-code-as-an-easy-way-to-debug-javascript"></a><h2 id="7-unminify-code-as-an-easy-way-to-debug-javascript-51">7. Unminify code as an easy way to debug JavaScript</h2>
<p>Sometimes you may have an issue in production, and your source maps didn't quite make it to the server. <u>Fear not.</u> Chrome can unminify your Javascript files to a more human-readable format. The code won't be as helpful as your real code – but at the very least you can see what's happening. Click the {} Pretty Print button below the source viewer in the inspector.</p>
<p><img src="https://assets-global.website-files.com/5e4bb125419b3343f60a3c85/5f235e8cb58c9e63be1a9173_5eaa4f824c1f30155edb9a12_Debugging-5.png" alt=""></p>
<a for="toc-anchor" id="8%5C.-quick-find-a-function-to-debug"></a><h2 id="8-quick-find-a-function-to-debug-51">8. Quick-find a function to debug</h2>
<p>Let's say you want to set a breakpoint in a function. The two most common ways to do that are:</p>
<p>‍&gt;1. Find the line in your inspector and add a breakpoint<br>
2. Add a debugger in your script&gt;</p>
<blockquote>
<p>‍&gt;</p>
</blockquote>
<p>In both of these solutions, you have to navigate manually around in your files to isolate the particular line you want to debug. What's probably less common is to use the console. Use debug(funcName) in the console and the script will stop when it reaches the function you passed in.</p>
<p>It's quick, but the downside is that it doesn't work on private or anonymous functions. Otherwise, it's probably the fastest way to find a function to debug. (Note: there's a function called console.debug which is not the same thing, despite the similar naming.)</p>
<p>var car;
var func1 = function() {</p>
<pre><code>func2();
</code></pre>
<p>}</p>
<p>var func2 = function() {</p>
<pre><code>func4();
</code></pre>
<p>}
var func3 = function() {
}</p>
<p>var func4 = function() {</p>
<pre><code>car = new Car();
car.funcX();
</code></pre>
<p>}
var Car = function() {</p>
<pre><code>this.brand = 'volvo'; 
this.color = 'red'; 
this.funcX = function() {
    this.funcY(); 
}

this.funcY = function() {
    this.funcZ(); 
}

this.funcZ = function() {
    console.trace('trace car')
}
</code></pre>
<p>}
func1();
var car;
var func1 = function() {</p>
<pre><code>func2();
</code></pre>
<p>}
var func2 = function() {</p>
<pre><code>func4();
</code></pre>
<p>}
var func3 = function() {
}
var func4 = function() {</p>
<pre><code>car = new Car();
car.funcX();
</code></pre>
<p>}
var Car = function() {</p>
<pre><code>this.brand = 'volvo'; 
this.color = 'red'; 
this.funcX = function() {
    this.funcY(); 
}

this.funcY = function() {
    this.funcZ(); 
}

 this.funcZ = function() {
    console.trace('trace car')
}
</code></pre>
<p>}
func1();</p>
<p>Type debug(car.funcY) in the console and the script will stop in debug mode when it gets a function call to car.funcY:</p>
<p><img src="https://assets-global.website-files.com/5e4bb125419b3343f60a3c85/5f235e8c52a9cf1a3b242494_5eaa50a14c1f30709fdba0e1_Debugging-6.png" alt=""></p>
<a for="toc-anchor" id="9%5C.-black-box-scripts-that-are-not-relevant"></a><h2 id="9-black-box-scripts-that-are-not-relevant-51">9. Black box scripts that are NOT relevant</h2>
<p>Today we often have a few libraries and frameworks on our web apps. Most of them are well tested and relatively bug-free. But, the debugger still steps into all the files that have no relevance for this debugging task. The solution is to black box the script you don't need to debug. This could also include your own scripts. Read more about <a href="https://raygun.com/blog/javascript-debugging-with-black-box/">debugging black box</a> in this article.</p>
<a for="toc-anchor" id="10%5C.-find-the-important-things-in-complex-debugging"></a><h2 id="10-find-the-important-things-in-complex-debugging-51">10. Find the important things in complex debugging</h2>
<p>In more complex debugging we sometimes want to output many lines. One thing you can do to keep a better structure of your outputs is to use more console functions, for example, console.log, console.debug, console.warn, console.info, console.error and so on. You can then filter them in your inspector. Sometimes this is not really what you want when you need to debug JavaScript. You can get creative and style your messages, if you so choose. Use CSS and make your own structured console messages when you want to debug JavaScript:</p>
<p>‍</p>
<p>console.todo = function(msg) {</p>
<pre><code>    console.log(' % c % s % s % s', 'color: yellow; background - color: black;', '–', msg, '–');
</code></pre>
<p>}</p>
<p>console.important = function(msg) {</p>
<pre><code>    console.log(' % c % s % s % s', 'color: brown; font - weight: bold; text - decoration: underline;', '–', msg, '–');
</code></pre>
<p>}</p>
<p>console.todo(&quot;This is something that' s need to be fixed&quot;);
console.important('This is an important message');</p>
<p>‍</p>
<p>Will output:</p>
<p>‍</p>
<p><img src="https://assets-global.website-files.com/5e4bb125419b3343f60a3c85/5f32220687db60118434aaa9_image13.png" alt=""></p>
<p>‍</p>
<p>In the console.log() you can set %s for a string, %i for integers and %c for custom style. You can probably find better ways to use these styles. If you use a single page framework, you might want to have one style for view messages and another for models, collections, controllers and so on.</p>
<a for="toc-anchor" id="11%5C.-watch-specific-function-calls-and-arguments"></a><h2 id="11-watch-specific-function-calls-and-arguments-51">11. Watch specific function calls and arguments</h2>
<p>In the Chrome console, you can keep an eye on specific functions. Every time the function is called, it will be logged with the values that it was passed in.</p>
<p>var func1 = function(x, y, z) {
//....
};</p>
<p>‍</p>
<p>Will output:</p>
<p><img src="https://assets-global.website-files.com/5e4bb125419b3343f60a3c85/5f235e8cd55d186b1c6cdb99_5eab735e58f6c673d762e275_Debugging-8.png" alt=""></p>
<p>This is a great way to see which arguments are passed into a function. Ideally, the console could tell how many arguments to expect, but it cannot. In the above example, func1 expects three arguments, but only two are passed in. If that's not handled in the code it could lead to a possible bug.</p>
<a for="toc-anchor" id="12%5C.-quickly-access-elements-in-the-console"></a><h2 id="12-quickly-access-elements-in-the-console-51">12. Quickly access elements in the console</h2>
<p>A faster way to do a querySelector in the console is with the dollar sign. <eq><span class="katex-error" title="ParseError: KaTeX parse error: Can&#x27;t use function &#x27;$1#x27; in math mode at position 63: … CSS selector. $̲" style="color:#cc0000">(&#x27;css-selector&#x27;) will return the first match of CSS selector. $</span></eq>('css-selector') will return all of them. If you are using an element more than once, it's worth saving it as a variable.</p>
<p><img src="https://assets-global.website-files.com/5e4bb125419b3343f60a3c85/5f235e8cab1b003c7a8dc12d_5eab73f78b32320be04ec35d_Debugging-10.png" alt=""></p>
<a for="toc-anchor" id="13%5C.-postman-is-great-(but-firefox-is-faster)"></a><h2 id="13-postman-is-great-but-firefox-is-faster-51">13. Postman is great (but Firefox is faster)</h2>
<p>Many developers are using Postman to play around with Ajax requests. <a href="https://www.postman.com/">Postman</a> is excellent, but it can be a bit annoying to open up a new browser window, write new request objects and then test them.</p>
<p>Sometimes it's easier to use your browser. When you do, you no longer need to worry about authentication cookies if you are sending to a password-secure page.</p>
<p>This is how you would edit and resend requests in Firefox. Open up the Inspector and go to the Network tab. Right-click on the desired request and choose Edit and Resend.</p>
<p>Now you can change anything you want. Change the header and edit your parameters and hit resend.</p>
<p>Below I present a request twice with different properties:</p>
<p><img src="https://assets-global.website-files.com/5e4bb125419b3343f60a3c85/5f235e8c9d7dcc576af10836_5eab74932d635749df313323_Debugging-11.png" alt=""></p>
<a for="toc-anchor" id="14%5C.-break-on-node-change"></a><h2 id="14-break-on-node-change-51">14. Break on node change</h2>
<p>The DOM can be a funny thing. Sometimes things change and you don't know why. However, when you need to debug JavaScript, Chrome lets you pause when a DOM element changes. You can even monitor its attributes. In Chrome Inspector, right-click on the element and pick a break on setting to use:</p>
<p><img src="https://assets-global.website-files.com/5e4bb125419b3343f60a3c85/5f235e8cf3a112611007ad01_5eab74ddbaab8647146433e8_Debugging-14.png" alt=""></p>
<a for="toc-anchor" id="15%5C.-use-page-speed-services"></a><h2 id="15-use-page-speed-services-51">15. Use page speed services</h2>
<p>There are plenty of services and tools out there that can be used to audit your page's JavaScript and help you to find slowdowns or problems. One of those tools is <a href="https://raygun.com/platform/real-user-monitoring">Raygun Real User Monitoring</a>. This can be useful for other reasons beyond locating JavaScript problems — slow loading external scripts, unnecessary CSS, oversized images. It can help you to become aware of JavaScript issues that are causing unintentionally long loading times, or failing to execute properly.</p>
<p>You'll also be able to measure improvements in JavaScript performance and track them over time.</p>
<p><img src="https://assets-global.website-files.com/5e4bb125419b3343f60a3c85/5f3227c70c33d57eedb4155b_real-user-monitoring%20(1).png" alt=""></p>
<a for="toc-anchor" id="16%5C.-breakpoints-everywhere"></a><h2 id="16-breakpoints-everywhere-51">16. Breakpoints everywhere</h2>
<p>Lastly, the tried and true breakpoint can be a success. Try using breakpoints in different ways for different situations.</p>
<p><img src="https://assets-global.website-files.com/5e4bb125419b3343f60a3c85/5f235e8de285f545c263f952_5eab75508b3232166d4ecf99_breakpoints.png" alt=""></p>
<p>You can click on an element and set a breakpoint, to stop execution when a certain element gets modified. You can also go into the Debugger tab or Sources tab (depending on your browser) in your developer tools, and set XHR breakpoints for any specific source to stop on Ajax requests. In the same location, you can also have it pause your code execution when exceptions occur. You can use these various kinds of breakpoints in your browser tools to maximize your chances of finding a bug while not having to invest time in outside tool sets.</p>
<a for="toc-anchor" id="tools"></a><h1 id="tools-51">TOOLS</h1>
<hr>
<a for="toc-anchor" id="the-best-javascript-debugging-tools-for-2020-and-beyond"></a><h1 id="the-best-javascript-debugging-tools-for-2020-and-beyond-51">The best JavaScript debugging tools for 2020 and beyond</h1>
<blockquote>
<p>‍</p>
</blockquote>
<a for="toc-anchor" id="1%5C.-developer-tools-in-modern-web-browsers"></a><h2 id="1-developer-tools-in-modern-web-browsers-51">1. Developer tools in modern web browsers</h2>
<p>Every modern browser has tools available within it to debug code. Let's take a look at some of the basic methods you might use to <a href="https://raygun.com/learn/javascript-debugging-tips">debug JavaScript</a> using these browser tools, and then highlight each major browser and its dev tools in turn.</p>
<blockquote>
<p>Outputting JavaScript debugging messages to the browser<br>
‍&gt;One of the easiest ways to debug JavaScript has always been to output data to the browser. Here are the three main ways to do so:</p>
</blockquote>
<blockquote>
<p>Popping up messages with \ <code>alert()\</code> &gt;<br>
A tried and true method to debug JavaScript items, \ <code>alert()\</code> will create a popup alert when your code meets a particular condition. The problem with alerts is that you end up with a series of popups.  If you need more than one, they become unwieldy rather fast. This makes them more useful for a quick check of a value or to find out if a certain bit of code is executing, but not much more.</p>
</blockquote>
<blockquote>
<p>Logging lines to console with \ <code>console.log()\</code> &gt;<br>
Logging to the console is the norm for JavaScript debugging. Adding a \ <code>console.log('foo');\</code> line to your code will create a \ <code>foo\</code> log entry in the JavaScript console of your respective dev tools set. This can be useful for a variety of reasons. For example, you can verify the value of a variable after you pass it to a method, or output the contents of an API response or results of a database query.</p>
</blockquote>
<blockquote>
<p>Pausing code execution with the \ <code>debugger\</code>
The \ <code>debugger;\</code> statement will pause code execution wherever you insert it in the code. The \ <code>debugger\</code> statement will function as a breakpoint, pausing code execution. This allows you to investigate with the dev tools while the code is in a paused state.</p>
</blockquote>
<a for="toc-anchor" id="chrome-developer-tools"></a><h2 id="chrome-developer-tools-51">Chrome developer tools</h2>
<blockquote>
<p>‍&gt;<br>
The <a href="https://developers.google.com/web/tools/chrome-devtools/javascript/">Chrome Developer Tools</a> are a quick way to debug your JavaScript code. You can open the Dev Tools to the Console tab by using the following shortcuts:<br>
‍<br>
macOS \ <code>CMD\</code> +\ <code>OPT\</code> +\ <code>I\</code>
Windows \ <code>CTRL\</code> +\ <code>SHIFT\</code> +\ <code>I\</code>
The Chrome Developer Tools are some of the best in the industry, and many developers trust these tools for their day-to-day debugging needs. Chrome Developer Tools include the standard JavaScript console, as well as tools for network and performance monitoring and security features. The majority of JavaScript debugging takes place in the Console and the Network activity tabs.</p>
</blockquote>
<a for="toc-anchor" id="react-developer-tools-for-chrome"></a><h2 id="react-developer-tools-for-chrome-51">React developer tools for Chrome</h2>
<blockquote>
<p>If you work with React as well as with JavaScript, there is an extension available called <a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi">React Developer Tools</a>. This tool set adds a React tab to your dev tools window. The React tools allow you to inspect the contents of components. You can also view and edit their properties and state. The tools provide insight on the component which created the selected component, as well. If you use Chrome as your main development browser, and develop in React, it is well worth picking up this extension to make your React debugging easier.</p>
</blockquote>
<a for="toc-anchor" id="firefox-developer-tools"></a><h2 id="firefox-developer-tools-51">Firefox developer tools</h2>
<blockquote>
<p>Firefox users in the past have relied on Firebug, an extension which gave Firefox users a set of competitive developer tools. The <a href="https://developer.mozilla.org/en-US/docs/Tools">Firefox Developer Tools</a> included in the latest versions of Firefox absorbed the functionality of Firebug. This brings the Firefox browser and its built-in tool suite on par with Google Chrome.</p>
</blockquote>
<p>To find the Firefox Developer Tools, take a look in the Tools menu under Web Developer. There, you will find the JavaScript console, and many other useful items.</p>
<a for="toc-anchor" id="safari-develop-menu"></a><h2 id="safari-develop-menu-51">Safari Develop Menu</h2>
<blockquote>
<p>Users of Safari have to enable the Safari Develop Menu to gain access to Safari's built in developer tools.</p>
</blockquote>
<p>- Go to the Safari tab and choose Preferences<br>
- Choose Advanced<br>
- Enable the option titled Show Develop menu in menu bar</p>
<p>Once you have followed the above steps, a Develop menu will appear in the toolbar. In the Develop menu, there are options to show the JavaScript Console, a debugger, a network traffic monitor, and an inspector for page elements. The Safari Dev Tools are comparable to the JavaScript debugging tools offered by Chrome. You can see the trend of improvement amongst the developer tools from all browsers, as they grow more capable of meeting the needs of developers.</p>
<a for="toc-anchor" id="%3Eopera-chromium-dev-tools%3E"></a><h2 id="blockquoteopera-chromium-dev-toolsblockquote-8">&gt;Opera Chromium dev tools&gt;</h2>
<blockquote>
<p>‍&gt;<br>
Previously, Opera's built in developer tools suite was called Dragonfly. At one point it was a standalone project, then became a baked-in part of Opera, and included the standard dev tools items. It was particularly useful at remotely debugging another instance of Opera. After Opera 12, Opera began shipping with Chromium Dev Tools instead, which are opened and operated similarly to the standard Chrome Dev Tools described above.</p>
</blockquote>
<a for="toc-anchor" id="%3Eedge-developer-tools%3E"></a><h2 id="blockquoteedge-developer-toolsblockquote-8">&gt;Edge Developer Tools&gt;</h2>
<blockquote>
<p>Microsoft Edge is a modern browser that broke away from many of the preconceived negative views of Internet Explorer. As a result, Microsoft Edge includes an excellent dev tools package, which can be accessed via the same shortcut keys as the other options. These tools include a JavaScript console, as well as Network, Performance, and Memory tabs. More information about Edge dev tools can be found in the <a href="https://docs.microsoft.com/en-us/microsoft-edge/devtools-guide">Microsoft Edge Developer Tools Guide</a>.</p>
</blockquote>
<a for="toc-anchor" id="2%5C.-the-hackable-debug-tool-%E2%80%94-debugger"></a><h2 id="2-the-hackable-debug-tool-debugger-51">2. The hackable debug tool — debugger</h2>
<p>The Firefox dev tools team maintains a standalone tool dubbed simply &quot;<a href="https://firefox-dev.tools/debugger/">debugger</a>&quot; that you can use to debug in either Firefox or Chrome, and you can switch between them as necessary to ensure that your application is functioning correctly in both. If you are willing to set this node app up with just a few simple steps, you can use it in lieu of using the in-browser tools in either browser, and get the same exact experience and identical comparison in both. Pretty neat!</p>
<a for="toc-anchor" id="3%5C.-node.js-inspector-for-debugging-requests-to-node-apps"></a><h2 id="3-nodejs-inspector-for-debugging-requests-to-node-apps-51">3. Node.js Inspector for debugging requests to Node apps</h2>
<p>Debugging the Node.js on your application's backend can be challenging. The following tools take advantage of the capabilities of the <a href="https://nodejs.org/en/docs/inspector/">Node.js Inspector</a> to assist you:</p>
<p>The <a href="https://github.com/nodejs/node-inspect">Node Debug library for Node Inspector</a> is a library can be included in your projects to assist you in implementing Node Inspector.</p>
<p>‍<a href="https://chrome.google.com/webstore/detail/nim-node-inspector-manage/gnhhdgbaldcilmgcpfddgdbkhjohddkj">Node.js V8 Inspector Manager</a> is a Chrome extension which adds Node Inspector tools to the Dev Tools in Chrome</p>
<p>The <a href="https://code.visualstudio.com/">Visual Studio Code</a> editor allows for easy built-in Node Inspector usage</p>
<p>- Click the Debug tab at the top<br>
- Choose Open Configurations<br>
- If none are set already, choose Node.js to start with<br>
- If you already have settings in the launch.json, you can hit Add Configuration to add the Node.js configuration</p>
<p>For more information on the various parameters and configurations that VS Code can use when debugging Node.js, check out the <a href="https://code.visualstudio.com/docs/nodejs/nodejs-debugging">Node.js debugging documentation</a>.</p>
<a for="toc-anchor" id="4%5C.-postman-for-debugging-requests-and-responses"></a><h2 id="4-postman-for-debugging-requests-and-responses-51">4. Postman for debugging requests and responses</h2>
<p>A non-trivial amount of JavaScript development revolves around sending requests to APIs and receiving responses. These requests and responses are often in JSON format. Your application may need to conduct API requests for innumerable reasons, such as interacting with authentication servers, fetching calendars or news feeds, checking the weather, and countless others.</p>
<p>‍<a href="https://www.getpostman.com/">Postman</a> is one of the best JavaScript debugging tools for troubleshooting the <a href="https://learning.getpostman.com/docs/postman/sending-api-requests/requests/">requests</a> and <a href="https://learning.getpostman.com/docs/postman/sending-api-requests/responses/">responses</a> in your application. Postman offers software for Windows, macOS, and Linux. With Postman, you can tweak requests, analyze responses, debug problems. Within the software, you can tailor clean transactions that you can then duplicate in your application.</p>
<p>Additionally, Postman has a feature called Collections. Collections allow you to save sets of requests and responses for your application or for an API. You save valuable time when collaborating with others or repeating the same testing tasks. When using Postman collections, you update the collection if necessary and then use it. This is much faster than repeatedly writing out every test.</p>
<a for="toc-anchor" id="5%5C.-eslint"></a><h2 id="5-eslint-51">5. ESLint</h2>
<p><a href="https://eslint.org/">ESLint</a> is a linter for JavaScript. Linters will analyze code as it is written and identify a variety of basic syntax problems. The use of ESLint will allow you to catch errors, particularly easy to resolve but annoying ones such as missing brackets or typos, before executing the code. ESLint is available as a Node package. It has also been set up as a plugin for many code editors such as Sublime Text 3 and VS Code, which will then mark the offending errors right in your editor window.</p>
<a for="toc-anchor" id="6%5C.-js-bin"></a><h2 id="6-js-bin-51">6. JS Bin</h2>
<p><a href="https://jsbin.com/">JS Bin</a> is one of the best JavaScript debugging tools for collaborative debugging of your JavaScript. It allows you to test and debug scripts right along with other people. You can run the JavaScript, see a debug console and the output of the scripts, add libraries and dependencies, and so much more. Pro accounts can also take their code private, as well as other benefits. One of the primary reasons you might consider using a tool like JS Bin is simplicity. In JS Bin, you can test the functionality of a small subset of your JavaScript in an isolated environment, without having to set an entire environment for it. When testing in JS Bin, you can be sure that your results aren't tainted by conflicting scripts or styles from other parts of your application. Another key feature of JS Bin is the immediate result you get from altering your JavaScript, HTML, or CSS. You can see your changes in real time. You can copy some code to JS Bin and have a working (or not working!) demo in no time. Then you are ready to debug it or share it.</p>
<a for="toc-anchor" id="7%5C.-json-formatter-and-validator"></a><h2 id="7-json-formatter-and-validator-51">7. JSON Formatter and Validator</h2>
<p>It can be incredibly difficult to spot syntax errors or keys which have incorrect values when looking at unformatted JSON. If you have a condensed or minified JSON object, missing line returns, indentations, and spaces, it may be a challenge to read. You need to be able to quickly scan that object and check for errors in formatting or content. To do that, you will expand the object and format it, wasting valuable time. The <a href="https://jsonformatter.curiousconcept.com/">JSON Formatter &amp; Validator</a> relieves that pain point, so we've added it to this list of what I feel are the best JavaScript debugging tools. Postman automatically formats the object and allows you to easily validate both its JSON syntax as well as the actual content. You simply paste your JSON in, and it outputs the correctly formatted version. The tool will even automatically validate syntax to RFC standards, depending on which you select, if any.</p>
<a for="toc-anchor" id="8%5C.-webpack"></a><h2 id="8-webpack-51">8. Webpack</h2>
<p><a href="https://webpack.js.org/">Webpack</a> is a bundling tool used by developers for all manner of sites and applications. If you use Webpack to do your bundling, you have the advantage of the <a href="https://webpack.js.org/api/stats/">stats data</a> available from the tool.</p>
<p>This data can range from module contents, build logs and errors, relationships that exist between modules, and much more. If you already use Webpack, this is an incredibly useful feature that sometimes gets overlooked. You can even use pre-built tools, such as the <a href="https://github.com/webpack/analyse">Webpack Analyse Web App</a>, to visualize the stats that you generate from Webpack.</p>
<a for="toc-anchor" id="9%5C.-sessionstack"></a><h2 id="9-sessionstack-51">9. SessionStack</h2>
<p><a href="https://www.sessionstack.com/">SessionStack</a> is a monitoring software that provides you with a set of monitoring tools. These tools collect client-side data and assist you in figuring out exactly what your clients are doing on your website. In situations where problems occur, being able to track precisely what happened and how is vital.</p>
<p>This is where SessionStack shines. SessionStack uses a video replay to help developers replicate user issues and error conditions.</p>
<p>Tip: If you use both SessionStack and Raygun, you can <a href="https://docs.sessionstack.com/docs/raygun">attach SessionStack video replays to Raygun reports</a>.</p>
<a for="toc-anchor" id="10%5C.-raygun-error-monitoring"></a><h2 id="10-raygun-error-monitoring-51">10. Raygun Error Monitoring</h2>
<p>Tired of spending time digging through logs to find your JavaScript errors? <a href="https://raygun.com/platform/crash-reporting">Raygun Crash Reporting</a> is the answer, and has everything you need to find and assess the impact of JavaScript bugs and performance problems. It's quick and easy to set up:</p>
<p>1. <a href="https://app.raygun.com/signup">Sign up</a> for a free trial of Raygun<br>
2. Insert the following snippet somewhere in your application's \ <code>&lt;head&gt;\</code> to fetch Raygun's script asynchronously.</p>
<pre><code class="language-js"><div>! <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> a, b, c, d, e, f, g, h </span>) </span>{
    a.RaygunObject = e, a\[ e\ ] = a\[ e\ ] || <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            ( a\[ e\ ].o = a\[ e\ ].o || \[ \] ).push( <span class="hljs-built_in">arguments</span> )
        }, f = b.createElement( c ), g = b.getElementsByTagName( c )\[ <span class="hljs-number">0</span>\ ],
        f.async = <span class="hljs-number">1</span>, f.src = d, g.parentNode.insertBefore( f, g ), h = a.onerror, a.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> b, c, d, f, g </span>) </span>{
            h &amp;&amp; h( b, c, d, f, g ), g || ( g = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>( b ) ), a\[ e\ ].q = a\[ e\ ].q || \[ \], a\[ e\ ].q.push( {
                <span class="hljs-attr">e</span>: g
            } )
        }
}( <span class="hljs-built_in">window</span>, <span class="hljs-built_in">document</span>, <span class="hljs-string">"script"</span>, <span class="hljs-string">",//cdn.raygun.io/raygun4js/raygun.min.js"</span>, <span class="hljs-string">"rg4js"</span> );
 
</div></code></pre>
<p>3. Paste the following lines just before your body tag (replacing the API key with yours, which you can get from your Raygun dashboard:</p>
<p>rg4js('apiKey', 'paste_your_api_key_here');
rg4js('enableCrashReporting', true);</p>
<p>4. At this point, Raygun will begin collecting data and notifying you of issues.</p>
<p>‍</p>

</body></html>